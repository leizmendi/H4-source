    ' $Id: basCrPKI.bas $

'/**
' The VBA/VB6 interface to CryptoSys PKI Pro.
'
' @author dai
' @version 20.6.0
'**/

' Last updated:
' * $Date: 2022-09-09 13:23:00 $

' From [v20.2]
' Combined all of basCrPKI.bas, basCrPKI64.bas, basCrPKI64_32.bas and basCrPKIWrappers.bas
' into this one file.

'************************* COPYRIGHT NOTICE*************************
' Copyright (c) 2002-22 DI Management Services Pty Limited.
' <www.di-mgt.com.au> <www.cryptosys.net>
' All rights reserved.
' The latest version of the CryptoSys PKI Toolkit and a licence
' may be obtained from <https://www.cryptosys.net/pki>.
' Refer to licence for conditions of use.
' This copyright notice must always be left intact.
'****************** END OF COPYRIGHT NOTICE*************************


Option Explicit
Option Base 0

' CONSTANTS
Public Const ENCRYPT As Long = -1
Public Const DECRYPT As Long = 0
Public Const PKI_DIR_ENCRYPT As Long = -1
Public Const PKI_DIR_DECRYPT As Long = 0
' Maximum number of bytes in hash digest byte array
Public Const PKI_MAX_HASH_BYTES As Long = 64
Public Const PKI_SHA1_BYTES     As Long = 20
Public Const PKI_SHA224_BYTES   As Long = 28
Public Const PKI_SHA256_BYTES   As Long = 32
Public Const PKI_SHA384_BYTES   As Long = 48
Public Const PKI_SHA512_BYTES   As Long = 64
Public Const PKI_MD5_BYTES      As Long = 16
Public Const PKI_MD2_BYTES      As Long = 16
Public Const PKI_RMD160_BYTES   As Long = 20
Public Const PKI_BTC160_BYTES   As Long = 20
' Maximum number of hex characters in hash digest
Public Const PKI_MAX_HASH_CHARS As Long = 2 * PKI_MAX_HASH_BYTES
Public Const PKI_SHA1_CHARS     As Long = 2 * PKI_SHA1_BYTES
Public Const PKI_SHA224_CHARS   As Long = 2 * PKI_SHA224_BYTES
Public Const PKI_SHA256_CHARS   As Long = 2 * PKI_SHA256_BYTES
Public Const PKI_SHA384_CHARS   As Long = 2 * PKI_SHA384_BYTES
Public Const PKI_SHA512_CHARS   As Long = 2 * PKI_SHA512_BYTES
Public Const PKI_MD5_CHARS      As Long = 2 * PKI_MD5_BYTES
Public Const PKI_MD2_CHARS      As Long = 2 * PKI_MD2_BYTES
Public Const PKI_RMD160_CHARS   As Long = 2 * PKI_RMD160_BYTES
Public Const PKI_BTC160_CHARS   As Long = 2 * PKI_BTC160_BYTES
' Synonym retained for backwards compatibility
Public Const PKI_MAX_HASH_LEN   As Long = PKI_MAX_HASH_CHARS
' Encryption block sizes in bytes
Public Const PKI_BLK_TDEA_BYTES     As Long = 8
Public Const PKI_BLK_AES_BYTES      As Long = 16
' Key size in bytes
Public Const PKI_KEYSIZE_TDEA_BYTES As Long = 24
Public Const PKI_KEYSIZE_MAX_BYTES  As Long = 32
' Required size for RNG seed file
Public Const PKI_RNG_SEED_BYTES     As Long = 64
' Length of GUID string - added [v12.3]
Public Const PKI_RNG_GUID_CHARS     As Long = 36
' Maximum number of characters in a last error message
Public Const PKI_MAX_LASTERROR_CHARS As Long = 647
Public Const PKI_MAX_ERROR_CHARS     As Long = PKI_MAX_LASTERROR_CHARS
' Maximum number of characters in an error lookup message
Public Const PKI_MAX_ERRORLOOKUP_CHARS As Long = 127

' CONSTANTS USED IN OPTION FLAGS
Public Const PKI_DEFAULT       As Long = 0

' Signature algorithms
Public Const PKI_SIG_SHA1RSA   As Long = &H0    ' default
Public Const PKI_SIG_MD5RSA    As Long = &H1
Public Const PKI_SIG_MD2RSA    As Long = &H2
Public Const PKI_SIG_SHA256RSA As Long = &H3
Public Const PKI_SIG_SHA384RSA As Long = &H4
Public Const PKI_SIG_SHA512RSA As Long = &H5
Public Const PKI_SIG_SHA224RSA As Long = &H6
' synonyms added [v12.0]
Public Const PKI_SIG_RSA_SHA1   As Long = &H0
Public Const PKI_SIG_RSA_SHA224 As Long = &H6
Public Const PKI_SIG_RSA_SHA256 As Long = &H3
Public Const PKI_SIG_RSA_SHA384 As Long = &H4
Public Const PKI_SIG_RSA_SHA512 As Long = &H5
Public Const PKI_SIG_RSA_MD5    As Long = &H1 ' [not recommended for new implementations]
' New in [v11.0] ...
Public Const PKI_SIG_ECDSA_SHA1   As Long = &H10
Public Const PKI_SIG_ECDSA_SHA224 As Long = &H20
Public Const PKI_SIG_ECDSA_SHA256 As Long = &H30
Public Const PKI_SIG_ECDSA_SHA384 As Long = &H40
Public Const PKI_SIG_ECDSA_SHA512 As Long = &H50
' New in [v12.0]...
Public Const PKI_SIG_RSA_PSS_SHA1   As Long = &HB0
Public Const PKI_SIG_RSA_PSS_SHA224 As Long = &HB6
Public Const PKI_SIG_RSA_PSS_SHA256 As Long = &HB3
Public Const PKI_SIG_RSA_PSS_SHA384 As Long = &HB4
Public Const PKI_SIG_RSA_PSS_SHA512 As Long = &HB5

' Safe curves for EdDSA - new in [v12.5]
Public Const PKI_SIG_ED25519 As Long = &HC0

'Safe curves for ECDH - new in [v12.5]
Public Const PKI_ECDH_X25519 As Long = &HD0

' Salt lengths for RSA-PSS - new in [v12.0]
Public Const PKI_PSS_SALTLEN_HLEN    As Long = &H0 ' default
Public Const PKI_PSS_SALTLEN_MAX     As Long = &H200000
Public Const PKI_PSS_SALTLEN_20      As Long = &H300000
Public Const PKI_PSS_SALTLEN_ZERO    As Long = &H400000

' MGF parameters for RSA-OAEP/PSS - new in [v12.0]
Public Const PKI_MGF_MGF1SHA1        As Long = &H800000

' PKCS#5 Password-based encryption algorithms
Public Const PKI_PBE_SHA_3DES  As Long = &H0    ' default
' Added in [v11.0] as simpler alternative to PKI_PBE_PBES2 + PKI_BC
Public Const PKI_PBE_PBKDF2_DESEDE3 As Long = &H1010&
Public Const PKI_PBE_PBKDF2_AES128  As Long = &H1020&
Public Const PKI_PBE_PBKDF2_AES192  As Long = &H1030&
Public Const PKI_PBE_PBKDF2_AES256  As Long = &H1040&
' These next 3 changed in [v11.0] (by adding 0x8000000)
Public Const PKI_PBE_MD5_DES As Long = &H8000001
Public Const PKI_PBE_MD2_DES As Long = &H8000002
Public Const PKI_PBE_SHA_DES As Long = &H8000003
' Synonym retained for backwards compatibility
Public Const PKI_PBES2_3DES  As Long = PKI_PBE_PBKDF2_DESEDE3
' Older alternative to specify PBES2 PBKDF2: Add PKI_BC_* option to specify encryption alg
Public Const PKI_PBE_PBES2   As Long = &H1000

' Message digest hash algorithms
Public Const PKI_HASH_SHA1     As Long = &H0  ' default
Public Const PKI_HASH_MD5      As Long = &H1
Public Const PKI_HASH_MD2      As Long = &H2
Public Const PKI_HASH_SHA256   As Long = &H3
Public Const PKI_HASH_SHA384   As Long = &H4
Public Const PKI_HASH_SHA512   As Long = &H5
Public Const PKI_HASH_SHA224   As Long = &H6
Public Const PKI_HASH_RMD160   As Long = &H7
Public Const PKI_HASH_BTC160   As Long = &H8
Public Const PKI_HASH_MODE_TEXT  As Long = &H10000
Public Const PKI_HASH_DOUBLE     As Long = &H20000

' HMAC algorithms
' Added [v11.0] as convenient synonyms
Public Const PKI_HMAC_SHA1     As Long = &H0
Public Const PKI_HMAC_SHA224   As Long = &H6
Public Const PKI_HMAC_SHA256   As Long = &H3
Public Const PKI_HMAC_SHA384   As Long = &H4
Public Const PKI_HMAC_SHA512   As Long = &H5

' CONSTANTS USED IN RSA EXPONENT PARAMETER
Public Const PKI_RSAEXP_EQ_3       As Long = 0
Public Const PKI_RSAEXP_EQ_5       As Long = 1
Public Const PKI_RSAEXP_EQ_17      As Long = 2
Public Const PKI_RSAEXP_EQ_257     As Long = 3
Public Const PKI_RSAEXP_EQ_65537   As Long = 4

' Return values for RSA_CheckKey
Public Const PKI_VALID_PUBLICKEY   As Long = 1
Public Const PKI_VALID_PRIVATEKEY  As Long = 0

' Options for ECC Keys - New in [v12.5]
Public Const PKI_ECC_PRIVATE_KEY As Long = &H0
Public Const PKI_ECC_PUBLIC_KEY  As Long = &H1

' BIT FLAGS

' Key generation and storage
Public Const PKI_KEYGEN_INDICATE   As Long = &H1000000
Public Const PKI_KEY_SECURE_OFF    As Long = &H2000000  ' New in [v20.4]
Public Const PKI_KEY_FORMAT_PEM    As Long = &H10000
Public Const PKI_KEY_FORMAT_SSL    As Long = &H20000
Public Const PKI_KEY_TYPE_PKCS8    As Long = &H40000

Public Const PKI_PFX_STRONG_CERT   As Long = &H1000000  ' New in [v12.3]
Public Const PKI_PFX_PLAIN_CERT    As Long = &H2000000
Public Const PKI_PFX_CLONE_KEY     As Long = &H4000000
Public Const PKI_PFX_ALT_FORMAT    As Long = &H100000
Public Const PKI_PFX_P7CHAIN       As Long = &H400
Public Const PKI_PFX_AES256_SHA256 As Long = &H1043     ' New in [v20.5]

Public Const PKI_CMS_FORMAT_BASE64  As Long = &H10000
Public Const PKI_CMS_EXCLUDE_CERTS    As Long = &H100
Public Const PKI_CMS_EXCLUDE_DATA     As Long = &H200
Public Const PKI_CMS_CERTS_ONLY       As Long = &H400
Public Const PKI_CMS_INCLUDE_ATTRS    As Long = &H800
Public Const PKI_CMS_ADD_SIGNTIME    As Long = &H1000
Public Const PKI_CMS_ADD_SMIMECAP    As Long = &H2000
Public Const PKI_CMS_ADD_SIGNINGCERT As Long = &H4000  ' New in [v12.4]
Public Const PKI_CMS_ADD_ALGPROTECT  As Long = &H8000  ' New in [v12.4]
Public Const PKI_CMS_NO_INFLATE   As Long = &H1000000
Public Const PKI_CMS_NO_OUTER     As Long = &H2000000
Public Const PKI_CMS_ALT_ALGID    As Long = &H4000000
Public Const PKI_CMS_BIGFILE      As Long = &H8000000
Public Const PKI_CMS_PSEUDOSIG     As Long = &H100000  ' New in [v20.2]

Public Const PKI_XML_RSAKEYVALUE   As Long = &H1
Public Const PKI_XML_EXCLPRIVATE   As Long = &H10
Public Const PKI_XML_REQPRIVATE    As Long = &H20
Public Const PKI_XML_HEXBINARY     As Long = &H100

Public Const PKI_EME_DEFAULT       As Long = &H0
Public Const PKI_EME_PKCSV1_5      As Long = &H0
Public Const PKI_EME_OAEP          As Long = &H10
Public Const PKI_EMSIG_DEFAULT     As Long = &H20
Public Const PKI_EMSIG_PKCSV1_5    As Long = &H20
Public Const PKI_EMSIG_DIGESTONLY  As Long = &H1000
Public Const PKI_EMSIG_DIGINFO     As Long = &H2000
Public Const PKI_EMSIG_ISO9796     As Long = &H100000

' X.509 Option flags
Public Const PKI_X509_FORMAT_PEM    As Long = &H10000
Public Const PKI_X509_FORMAT_BIN    As Long = &H20000
Public Const PKI_X509_REQ_KLUDGE   As Long = &H100000
Public Const PKI_X509_NO_TIMECHECK As Long = &H200000
Public Const PKI_X509_LATIN1       As Long = &H400000
Public Const PKI_X509_UTF8         As Long = &H800000
Public Const PKI_X509_AUTHKEYID   As Long = &H1000000
Public Const PKI_X509_NO_BASIC    As Long = &H2000000
Public Const PKI_X509_CA_TRUE     As Long = &H4000000
Public Const PKI_X509_VERSION1    As Long = &H8000000
Public Const PKI_X509_LDAP        As Long = &H1000
Public Const PKI_X509_DECIMAL     As Long = &H8000&     ' NB "&" at end

' Flags for X.509 Key Usage
Public Const PKI_X509_KEYUSAGE_DIGITALSIGNATURE  As Long = &H1
Public Const PKI_X509_KEYUSAGE_NONREPUDIATION    As Long = &H2
Public Const PKI_X509_KEYUSAGE_KEYENCIPHERMENT   As Long = &H4
Public Const PKI_X509_KEYUSAGE_DATAENCIPHERMENT  As Long = &H8
Public Const PKI_X509_KEYUSAGE_KEYAGREEMENT      As Long = &H10
Public Const PKI_X509_KEYUSAGE_KEYCERTSIGN       As Long = &H20
Public Const PKI_X509_KEYUSAGE_CRLSIGN           As Long = &H40
Public Const PKI_X509_KEYUSAGE_ENCIPHERONLY      As Long = &H80
Public Const PKI_X509_KEYUSAGE_DECIPHERONLY      As Long = &H100

' SPECIFIC X509 RETURN VALUES
' [v12.0] Changed from +1/-1 to proper error codes
Public Const PKI_X509_EXPIRED        As Long = 16   ' (EXPIRED_ERROR) CHANGED FROM -1 [v12.0]
Public Const PKI_X509_VERIFY_FAILURE As Long = 22   ' (SIGNATURE_ERROR) CHANGED FROM -1 [v12.0]
Public Const PKI_X509_REVOKED        As Long = 42   ' (REVOCATION_ERROR) CHANGED FROM +1 [v12.0]
Public Const PKI_X509_INVALID        As Long = 43   ' (CERT_PATH_ERROR) CHANGED FROM +1 [v12.0]
Public Const PKI_X509_VALID_NOW      As Long = 0
Public Const PKI_X509_VERIFY_SUCCESS As Long = 0

' RETURN VALUES FOR CNV_CheckUTF
Public Const PKI_CHRS_NOT_UTF8   As Long = 0
Public Const PKI_CHRS_ALL_ASCII  As Long = 1
Public Const PKI_CHRS_ANSI8      As Long = 2
Public Const PKI_CHRS_MULTIBYTE  As Long = 3

' Options for CNV_ByteEncoding
Public Const PKI_CNV_UTF8_FROM_LATIN1 As Long = &H1
Public Const PKI_CNV_LATIN1_FROM_UTF8 As Long = &H2

' Options for CNV_Num[To/From]Bytes. New in [v11.0]
Public Const PKI_CNV_BIG_ENDIAN    As Long = &H0    ' default
Public Const PKI_CNV_LITTLE_ENDIAN As Long = &H1

' FLAGS AND RETURN VALUES FOR X.509 AND CMS QUERY FUNCTIONS
Public Const PKI_QUERY_GETTYPE    As Long = &H100000
Public Const PKI_QUERY_NUMBER     As Long = 1
Public Const PKI_QUERY_STRING     As Long = 2

' OPTIONS FOR RNG FUNCTIONS
Public Const PKI_RNG_STRENGTH_112 As Long = &H0 ' default
Public Const PKI_RNG_STRENGTH_128 As Long = &H1

' Block cipher (BC) algorithm options
Public Const PKI_BC_TDEA    As Long = &H10  ' )
Public Const PKI_BC_DESEDE3 As Long = &H10  ' ) equiv. synonyms for Triple DES
Public Const PKI_BC_3DES    As Long = &H10  ' )
Public Const PKI_BC_AES128  As Long = &H20
Public Const PKI_BC_AES192  As Long = &H30
Public Const PKI_BC_AES256  As Long = &H40
' Block cipher mode options
Public Const PKI_MODE_ECB  As Long = &H0
Public Const PKI_MODE_CBC  As Long = &H100
Public Const PKI_MODE_OFB  As Long = &H200
Public Const PKI_MODE_CFB  As Long = &H300
Public Const PKI_MODE_CTR  As Long = &H400
' Added [v12.1] AEAD only
Public Const PKI_MODE_GCM  As Long = &H500

' Block cipher padding options
Public Const PKI_PAD_DEFAULT As Long = &H0
Public Const PKI_PAD_NOPAD  As Long = &H10000
Public Const PKI_PAD_PKCS5  As Long = &H20000
Public Const PKI_PAD_1ZERO  As Long = &H30000
Public Const PKI_PAD_AX923  As Long = &H40000
Public Const PKI_PAD_W3C    As Long = &H50000

' AEAD algorithms - added [v12.1]
Public Const PKI_AEAD_AES_128_GCM  As Long = &H520
Public Const PKI_AEAD_AES_192_GCM  As Long = &H530
Public Const PKI_AEAD_AES_256_GCM  As Long = &H540

' Block cipher option flags
Public Const PKI_IV_PREFIX  As Long = &H1000

' Key wrap algorithms - added [v20.5]
Public Const PKI_KWRAP_3DES   As Long = &H100000
Public Const PKI_KWRAP_AES128 As Long = &H200000
Public Const PKI_KWRAP_AES192 As Long = &H300000
Public Const PKI_KWRAP_AES256 As Long = &H400000

' Key transport algorithms
Public Const PKI_KT_RSAES_PKCS As Long = &H0     ' Default
Public Const PKI_KT_RSAES_OAEP As Long = &H8000& ' added [v12.0]

' Key derivation functions
' Changed [v20.5]
'Public Const PKI_KDF_KDF2      As Long = &H0    ' Historical, never used
Public Const PKI_KDF_X963      As Long = &H0    ' Default
Public Const PKI_KDF_HKDF      As Long = &H1000

' ASN.1 utilities - added [v10.0]
Public Const PKI_ASN1_NOCOMMENTS As Long = &H100000
Public Const PKI_ASN1_ADDLEVELS  As Long = &H800000
Public Const PKI_ASN1_TYPE_MAXCHARS As Long = 64

' SIG functions
Public Const PKI_SIG_USEDIGEST     As Long = &H1000   ' added [v10.0]
Public Const PKI_SIG_DETERMINISTIC As Long = &H2000   ' added [v11.0]
Public Const PKI_SIG_ASN1DER       As Long = &H4000   ' added [v11.0], changed from 0x200000 [v12.0]

' SMIME functions - added [v10.0]
Public Const PKI_SMIME_ENCODE_BASE64 As Long = &H10000
Public Const PKI_SMIME_ENCODE_BINARY As Long = &H20000
Public Const PKI_SMIME_ADDX          As Long = &H100000

' Encoding options - added [v11.0]
Public Const PKI_ENCODE_HEX       As Long = &H30000
Public Const PKI_ENCODE_BASE64URL As Long = &H40000

' Wipefile options - added [v12.0]
Public Const PKI_WIPEFILE_DOD7   As Long = &H0  ' default
Public Const PKI_WIPEFILE_SIMPLE As Long = &H1

' General
Public Const PKI_GEN_PLATFORM As Long = &H40
Public Const PKI_GEN_LEGACY   As Long = &H8000000  ' Added [v11.0]


' *********************
' FUNCTION DECLARATIONS
' *********************

#If VBA7 Then
    ' Declarations for 64-bit Office
    ' (In VB6 these will appear red. Turn off "Auto Syntax Check" in Tools > Options to avoid annoying warnings)
    
    ' CRYPTOGRAPHIC MESSAGE SYNTAX (CMS) FUNCTIONS
    Public Declare PtrSafe Function CMS_MakeEnvData Lib "diCrPKI.dll" (ByVal strFileOut As String, ByVal strFileIn As String, ByVal strCertList As String, ByVal strSeed As String, ByVal nSeedLen As Long, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function CMS_MakeEnvDataFromString Lib "diCrPKI.dll" (ByVal strFileOut As String, ByVal strDataIn As String, ByVal strCertList As String, ByVal strSeed As String, ByVal nSeedLen As Long, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function CMS_ReadEnvData Lib "diCrPKI.dll" (ByVal strFileOut As String, ByVal strFileIn As String, ByVal strCertFile As String, ByVal strPrivateKey As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function CMS_ReadEnvDataToString Lib "diCrPKI.dll" (ByVal strDataOut As String, ByVal nDataLen As Long, ByVal strFileIn As String, ByVal strCertFile As String, ByVal strPrivateKey As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function CMS_MakeSigData Lib "diCrPKI.dll" (ByVal strFileOut As String, ByVal strFileIn As String, ByVal strCertList As String, ByVal strPrivateKey As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function CMS_MakeSigDataFromString Lib "diCrPKI.dll" (ByVal strFileOut As String, ByVal strDataIn As String, ByVal strCertList As String, ByVal strPrivateKey As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function CMS_MakeSigDataFromSigValue Lib "diCrPKI.dll" (ByVal strFileOut As String, ByRef lpSigValue As Byte, ByVal nSigLen As Long, ByRef lpData As Byte, ByVal nDataLen As Long, ByVal strCertList As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function CMS_MakeDetachedSig Lib "diCrPKI.dll" (ByVal strFileOut As String, ByVal strHexDigest As String, ByVal strCertList As String, ByVal strPrivateKey As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function CMS_ReadSigData Lib "diCrPKI.dll" (ByVal strFileOut As String, ByVal strFileIn As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function CMS_ReadSigDataToString Lib "diCrPKI.dll" (ByVal strDataOut As String, ByVal nDataLen As Long, ByVal strFileIn As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function CMS_GetSigDataDigest Lib "diCrPKI.dll" (ByVal strHexDigest As String, ByVal nHexDigestLen As Long, ByVal strFileIn As String, ByVal strCertFile As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function CMS_VerifySigData Lib "diCrPKI.dll" (ByVal strFileIn As String, ByVal strCertFile As String, ByVal strHexDigest As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function CMS_QuerySigData Lib "diCrPKI.dll" (ByVal strDataOut As String, ByVal nDataLen As Long, ByVal strFileIn As String, ByVal strQuery As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function CMS_QueryEnvData Lib "diCrPKI.dll" (ByVal strDataOut As String, ByVal nDataOutLen As Long, ByVal strFileIn As String, ByVal strQuery As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function CMS_MakeComprData Lib "diCrPKI.dll" (ByVal strFileOut As String, ByVal strFileIn As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function CMS_ReadComprData Lib "diCrPKI.dll" (ByVal strFileOut As String, ByVal strFileIn As String, ByVal nOptions As Long) As Long
    ' New in [v12.2]
    Public Declare PtrSafe Function CMS_ReadEnvDataToBytes Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutBytes As Long, ByVal strFileIn As String, ByVal strCertFile As String, ByVal strPrivateKey As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function CMS_ReadSigDataToBytes Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutBytes As Long, ByVal strFileIn As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function CMS_MakeEnvDataFromBytes Lib "diCrPKI.dll" (ByVal strFileOut As String, ByRef lpInput As Byte, ByVal nInputLen As Long, ByVal strCertList As String, ByVal strSeed As String, ByVal nSeedLen As Long, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function CMS_MakeSigDataFromBytes Lib "diCrPKI.dll" (ByVal strFileOut As String, ByRef lpInput As Byte, ByVal nInputLen As Long, ByVal strCertList As String, ByVal strPrivateKey As String, ByVal nOptions As Long) As Long
    
    ' RSA PUBLIC KEY FUNCTIONS
    ' New in [v12.3]
    Public Declare PtrSafe Function RSA_MakeKeysXtd Lib "diCrPKI.dll" (ByVal strPubKeyFile As String, ByVal strPriKeyFile As String, ByVal strPassword As String, ByVal nBits As Long, ByVal nExpFermat As Long, ByVal strParams As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function RSA_SaveEncKey Lib "diCrPKI.dll" (ByVal strFileOut As String, ByVal strIntKeyString As String, ByVal strPassword As String, ByVal strParams As String, ByVal nOptions As Long) As Long
    
    Public Declare PtrSafe Function RSA_MakeKeys Lib "diCrPKI.dll" (ByVal strPubKeyFile As String, ByVal strPvkKeyFile As String, ByVal nBits As Long, ByVal nExpFermat As Long, ByVal nTests As Long, ByVal nCount As Long, ByVal strPassword As String, ByVal strSeed As String, ByVal nSeedLen As Long, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function RSA_SavePublicKey Lib "diCrPKI.dll" (ByVal strOutputFile As String, ByVal strPublicKey As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function RSA_SaveEncPrivateKey Lib "diCrPKI.dll" (ByVal strOutputFile As String, ByVal strPrivateKey As String, ByVal nCount As Long, ByVal strPassword As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function RSA_SavePrivateKeyInfo Lib "diCrPKI.dll" (ByVal strOutputFile As String, ByVal strPrivateKey As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function RSA_GetPrivateKeyFromPFX Lib "diCrPKI.dll" (ByVal strOutputFile As String, ByVal strPfxFile As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function RSA_ToXMLString Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutputLen As Long, ByVal strKeyString As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function RSA_ToXMLStringEx Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strKeyString As String, ByVal strPrefix As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function RSA_FromXMLString Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutputLen As Long, ByVal strXmlString As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function RSA_KeyBits Lib "diCrPKI.dll" (ByVal strKey As String) As Long
    Public Declare PtrSafe Function RSA_KeyBytes Lib "diCrPKI.dll" (ByVal strKey As String) As Long
    Public Declare PtrSafe Function RSA_CheckKey Lib "diCrPKI.dll" (ByVal strKey As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function RSA_KeyHashCode Lib "diCrPKI.dll" (ByVal strKeyString As String) As Long
    Public Declare PtrSafe Function RSA_KeyMatch Lib "diCrPKI.dll" (ByVal strPrivateKey As String, ByVal strPublicKey As String) As Long
    Public Declare PtrSafe Function RSA_PublicKeyFromPrivate Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strKeyString As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function RSA_ReadAnyPrivateKey Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strKeyFile As String, ByVal strPassword As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function RSA_ReadAnyPublicKey Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strKeyFile As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function RSA_KeyValue Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strKeyString As String, ByVal strFieldName As String, ByVal nOptions As Long) As Long
    
    ' The following five functions are @deprecated - prefer RSA_ReadAnyPrivateKey or RSA_ReadAnyPublicKey.
    Public Declare PtrSafe Function RSA_ReadEncPrivateKey Lib "diCrPKI.dll" (ByVal strPrivateKey As String, ByVal nKeyMaxLen As Long, ByVal strEpkFileName As String, ByVal strPassword As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function RSA_ReadPrivateKeyInfo Lib "diCrPKI.dll" (ByVal strPrivateKey As String, ByVal nKeyMaxLen As Long, ByVal strPriFileName As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function RSA_ReadPrivateKeyFromPFX Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strPfxFile As String, ByVal strPassword As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function RSA_ReadPublicKey Lib "diCrPKI.dll" (ByVal strPublicKey As String, ByVal nKeyMaxLen As Long, ByVal strKeyFileName As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function RSA_GetPublicKeyFromCert Lib "diCrPKI.dll" (ByVal strPublicKey As String, ByVal nKeyMaxLen As Long, ByVal strCertFileName As String, ByVal nOptions As Long) As Long
    
    ' "RAW" RSA ENCRYPTION/DECRYPTION FUNCTIONS
    Public Declare PtrSafe Function RSA_RawPublic Lib "diCrPKI.dll" (ByRef lpData As Byte, ByVal nDataLen As Long, ByVal strPublicKey As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function RSA_RawPrivate Lib "diCrPKI.dll" (ByRef lpData As Byte, ByVal nDataLen As Long, ByVal strPrivateKey As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function RSA_EncodeMsg Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutputLen As Long, ByRef lpMessage As Byte, ByVal nMsgLen As Long, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function RSA_DecodeMsg Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutputLen As Long, ByRef lpInput As Byte, ByVal nInputLen As Long, ByVal nOptions As Long) As Long
    ' New in [v12.0]
    Public Declare PtrSafe Function RSA_Encrypt Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutBytes As Long, ByRef lpInput As Byte, ByVal nInputLen As Long, ByVal strPublicKeyFile As String, ByVal strParameters As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function RSA_Decrypt Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutBytes As Long, ByRef lpInput As Byte, ByVal nInputLen As Long, ByVal strPrivateKeyFile As String, ByVal strPassword As String, ByVal strParameters As String, ByVal nOptions As Long) As Long
    
    ' ELLIPTIC CURVE CRYPTOGRAPHY FUNCTIONS
    ' New in [v11.0]
    Public Declare PtrSafe Function ECC_MakeKeys Lib "diCrPKI.dll" (ByVal strPubKeyFile As String, ByVal strPriKeyFile As String, ByVal strCurveName As String, ByVal strPassword As String, ByVal strParams As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function ECC_ReadKeyByCurve Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strHexKey As String, ByVal strCurveName As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function ECC_ReadPrivateKey Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strKeyFileOrString As String, ByVal strPassword As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function ECC_ReadPublicKey Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strKeyFileOrString As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function ECC_SaveEncKey Lib "diCrPKI.dll" (ByVal strFileOut As String, ByVal strIntKeyString As String, ByVal strPassword As String, ByVal strParams As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function ECC_SaveKey Lib "diCrPKI.dll" (ByVal strFileOut As String, ByVal strIntKeyString As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function ECC_PublicKeyFromPrivate Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strIntKeyString As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function ECC_QueryKey Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strIntKeyString As String, ByVal strQuery As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function ECC_KeyHashCode Lib "diCrPKI.dll" (ByVal strKeyString As String) As Long
    ' New in [v12.5]
    Public Declare PtrSafe Function ECC_DHSharedSecret Lib "diCrPKI.dll" (ByRef lpZZ As Byte, ByVal nOutBytes As Long, ByVal strIntPrivateKey As String, ByVal strIntPublicKey As String, ByVal nOptions As Long) As Long
    
    ' PFX (PKCS-12) FUNCTIONS
    Public Declare PtrSafe Function PFX_MakeFile Lib "diCrPKI.dll" (ByVal strOutputFile As String, ByVal strCertFile As String, ByVal strKeyFile As String, ByVal strPassword As String, ByVal strFriendlyName As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function PFX_VerifySig Lib "diCrPKI.dll" (ByVal strFileName As String, ByVal strPassword As String, ByVal nOptions As Long) As Long
        
    ' X.509 CERTIFICATE FUNCTIONS
    Public Declare PtrSafe Function X509_MakeCertSelf Lib "diCrPKI.dll" (ByVal strNewCertFile As String, ByVal strEPKFile As String, ByVal nCertNum As Long, ByVal nYearsValid As Long, ByVal strDistName As String, ByVal strExtensions As String, ByVal KeyUsageFlags As Long, ByVal strPassword As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function X509_MakeCert Lib "diCrPKI.dll" (ByVal strNewCertFile As String, ByVal strIssuerCertFile As String, ByVal strSubjectPubKeyFile As String, ByVal strIssuerPvkInfoFile As String, ByVal nCertNum As Long, ByVal nYearsValid As Long, ByVal strDistName As String, ByVal strExtensions As String, ByVal KeyUsageFlags As Long, ByVal strPassword As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function X509_CertRequest Lib "diCrPKI.dll" (ByVal strReqFile As String, ByVal strEPKFile As String, ByVal strDistName As String, ByVal strExtensions As String, ByVal strPassword As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function X509_VerifyCert Lib "diCrPKI.dll" (ByVal strCertToVerify As String, ByVal strIssuerCert As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function X509_CertThumb Lib "diCrPKI.dll" (ByVal strCertFile As String, ByVal strHexHash As String, ByVal nHexHashLen As Long, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function X509_CertIsValidNow Lib "diCrPKI.dll" (ByVal strCertFile As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function X509_CertIssuedOn Lib "diCrPKI.dll" (ByVal strCertFile As String, ByVal strOutput As String, ByVal nOutputLen As Long, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function X509_CertExpiresOn Lib "diCrPKI.dll" (ByVal strCertFile As String, ByVal strOutput As String, ByVal nOutputLen As Long, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function X509_CertSerialNumber Lib "diCrPKI.dll" (ByVal strCertFile As String, ByVal strOutput As String, ByVal nOutputLen As Long, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function X509_CertIssuerName Lib "diCrPKI.dll" (ByVal strCertFile As String, ByVal strOutput As String, ByVal nOutputLen As Long, ByVal strDelim As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function X509_CertSubjectName Lib "diCrPKI.dll" (ByVal strCertFile As String, ByVal strOutput As String, ByVal nOutputLen As Long, ByVal strDelim As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function X509_HashIssuerAndSN Lib "diCrPKI.dll" (ByVal strCertFile As String, ByVal strOutput As String, ByVal nOutputLen As Long, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function X509_GetCertFromP7Chain Lib "diCrPKI.dll" (ByVal strOutputFile As String, ByVal strP7cFile As String, ByVal nIndex As Long, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function X509_GetCertFromPFX Lib "diCrPKI.dll" (ByVal strOutputFile As String, ByVal strPfxFile As String, ByVal strPassword As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function X509_KeyUsageFlags Lib "diCrPKI.dll" (ByVal strCertFile As String) As Long
    Public Declare PtrSafe Function X509_QueryCert Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strFileIn As String, ByVal szQuery As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function X509_ReadStringFromFile Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strCertFile As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function X509_SaveFileFromString Lib "diCrPKI.dll" (ByVal strNewCertFile As String, ByVal strCertString As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function X509_TextDump Lib "diCrPKI.dll" (ByVal strFileOut As String, ByVal strCertFile As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function X509_ValidatePath Lib "diCrPKI.dll" (ByVal strCertListOrP7File As String, ByVal strTrustedCert As String, ByVal nOptions As Long) As Long
    ' New in [v12.0]
    Public Declare PtrSafe Function X509_TextDumpToString Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strCertFile As String, ByVal nOptions As Long) As Long
    ' New in [v12.1]
    Public Declare PtrSafe Function X509_ReadCertStringFromP7Chain Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strP7cFile As String, ByVal nIndex As Long, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function X509_ReadCertStringFromPFX Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strPfxFile As String, ByVal strPassword As String, ByVal nOptions As Long) As Long
    ' New in [v12.2]
    Public Declare PtrSafe Function X509_GetCertCountInP7Chain Lib "diCrPKI.dll" (ByVal strP7cFile As String, ByVal nOptions As Long) As Long
    
    ' X509 CRL FUNCTIONS
    Public Declare PtrSafe Function X509_MakeCRL Lib "diCrPKI.dll" (ByVal strCrlFile As String, ByVal strIssuerCert As String, ByVal strIssuerKeyFile As String, ByVal strPassword As String, ByVal strRevokedCertList As String, ByVal strExtensions As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function X509_CheckCertInCRL Lib "diCrPKI.dll" (ByVal strCertFile As String, ByVal strCrlFile As String, ByVal strCRLIssuerCert As String, ByVal strDate As String, ByVal nOptions As Long) As Long
    
    ' ONLINE CERTIFICATE STATUS PROTOCOL (OCSP) FUNCTIONS
    Public Declare PtrSafe Function OCSP_MakeRequest Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strIssuerCert As String, ByVal strCertFileOrSerialNum As String, ByVal strExtensions As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function OCSP_ReadResponse Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strResponseFile As String, ByVal strIssuerCert As String, ByVal strExtensions As String, ByVal nOptions As Long) As Long
    
    ' TRIPLE DATA ENCRYPTION ALGORITHM (TDEA/3DES/TRIPLE DES) BLOCK CIPHER FUNCTIONS
    ' [@deprecated - use CIPHER_ functions]
    Public Declare PtrSafe Function TDEA_BytesMode Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByRef lpInput As Byte, ByVal nDataLen As Long, ByRef lpKey As Byte, ByVal bEncrypt As Long, ByVal strMode As String, ByRef lpIV As Byte) As Long
    Public Declare PtrSafe Function TDEA_HexMode Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal strInput As String, ByVal strKey As String, ByVal bEncrypt As Long, ByVal strMode As String, ByVal strIV As String) As Long
    Public Declare PtrSafe Function TDEA_B64Mode Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal strInput As String, ByVal strKey As String, ByVal bEncrypt As Long, ByVal strMode As String, ByVal strIV As String) As Long
    Public Declare PtrSafe Function TDEA_File Lib "diCrPKI.dll" (ByVal strFileOut As String, ByVal strFileIn As String, ByRef lpKey As Byte, ByVal bEncrypt As Long, ByVal strMode As String, ByRef lpIV As Byte) As Long
    
    ' GENERIC BLOCK CIPHER FUNCTIONS
    Public Declare PtrSafe Function CIPHER_Hex Lib "diCrPKI.dll" (ByVal fEncrypt As Long, ByVal strOutput As String, ByVal nOutChars As Long, ByVal strData As String, ByVal strKey As String, ByVal strIV As String, ByVal strAlgAndMode As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function CIPHER_KeyWrap Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutBytes As Long, ByRef lpData As Byte, ByVal nDataLen As Long, ByRef lpKEK As Byte, ByVal nKekLen As Long, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function CIPHER_KeyUnwrap Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutBytes As Long, ByRef lpData As Byte, ByVal nDataLen As Long, ByRef lpKEK As Byte, ByVal nKekLen As Long, ByVal nOptions As Long) As Long
    ' [The following two functions are @deprecated]
    Public Declare PtrSafe Function CIPHER_Bytes Lib "diCrPKI.dll" (ByVal fEncrypt As Long, ByRef lpOutput As Byte, ByRef lpData As Byte, ByVal nDataLen As Long, ByRef lpKey As Byte, ByRef lpIV As Byte, ByVal strAlgAndMode As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function CIPHER_File Lib "diCrPKI.dll" (ByVal fEncrypt As Long, ByVal strFileOut As String, ByVal strFileIn As String, ByRef lpKey As Byte, ByRef lpIV As Byte, ByVal strAlgAndMode As String, ByVal nOptions As Long) As Long
    ' Added in [v20.2] (to get rid of that annoying 2)
    Public Declare PtrSafe Function CIPHER_EncryptBytes Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutBytes As Long, ByRef lpInput As Byte, ByVal nInputLen As Long, ByRef lpKey As Byte, ByVal nKeyLen As Long, ByRef lpIV As Byte, ByVal nIVLen As Long, ByVal strAlgModePad As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function CIPHER_DecryptBytes Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutBytes As Long, ByRef lpInput As Byte, ByVal nInputLen As Long, ByRef lpKey As Byte, ByVal nKeyLen As Long, ByRef lpIV As Byte, ByVal nIVLen As Long, ByVal strAlgModePad As String, ByVal nOptions As Long) As Long
    ' Aliases for backwards compatibility
    Public Declare PtrSafe Function CIPHER_EncryptBytes2 Lib "diCrPKI.dll" Alias "CIPHER_EncryptBytes" (ByRef lpOutput As Byte, ByVal nOutBytes As Long, ByRef lpInput As Byte, ByVal nInputLen As Long, ByRef lpKey As Byte, ByVal nKeyLen As Long, ByRef lpIV As Byte, ByVal nIVLen As Long, ByVal strAlgModePad As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function CIPHER_DecryptBytes2 Lib "diCrPKI.dll" Alias "CIPHER_DecryptBytes" (ByRef lpOutput As Byte, ByVal nOutBytes As Long, ByRef lpInput As Byte, ByVal nInputLen As Long, ByRef lpKey As Byte, ByVal nKeyLen As Long, ByRef lpIV As Byte, ByVal nIVLen As Long, ByVal strAlgModePad As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function CIPHER_FileEncrypt Lib "diCrPKI.dll" (ByVal strFileOut As String, ByVal strFileIn As String, ByRef lpKey As Byte, ByVal nKeyLen As Long, ByRef lpIV As Byte, ByVal nIVLen As Long, ByVal strAlgModePad As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function CIPHER_FileDecrypt Lib "diCrPKI.dll" (ByVal strFileOut As String, ByVal strFileIn As String, ByRef lpKey As Byte, ByVal nKeyLen As Long, ByRef lpIV As Byte, ByVal nIVLen As Long, ByVal strAlgModePad As String, ByVal nOptions As Long) As Long
    ' New in [v12.1]
    Public Declare PtrSafe Function CIPHER_EncryptAEAD Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutBytes As Long, ByRef lpInput As Byte, ByVal nInputLen As Long, ByRef lpKey As Byte, ByVal nKeyLen As Long, ByRef lpIV As Byte, ByVal nIVLen As Long, ByRef lpAAD As Byte, ByVal nAadLen As Long, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function CIPHER_DecryptAEAD Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutBytes As Long, ByRef lpInput As Byte, ByVal nInputLen As Long, ByRef lpKey As Byte, ByVal nKeyLen As Long, ByRef lpIV As Byte, ByVal nIVLen As Long, ByRef lpAAD As Byte, ByVal nAadLen As Long, ByVal nOptions As Long) As Long
    ' New in [v12.5]
    Public Declare PtrSafe Function CIPHER_EncryptHex Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strInputHex As String, ByVal strKeyHex As String, ByVal strIvHex As String, ByVal strAlgModePad As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function CIPHER_DecryptHex Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strInputHex As String, ByVal strKeyHex As String, ByVal strIvHex As String, ByVal strAlgModePad As String, ByVal nOptions As Long) As Long
    
    ' MESSAGE DIGEST HASH FUNCTIONS
    Public Declare PtrSafe Function HASH_HexFromBytes Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByRef lpMessage As Byte, ByVal nMsgLen As Long, ByVal nOptions As Long) As Long
    ' Alternative alias of HASH_HexFromBytes to cope with ANSI strings (VB6/VBA only)...
    Public Declare PtrSafe Function HASH_HexFromString Lib "diCrPKI.dll" Alias "HASH_HexFromBytes" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strMessage As String, ByVal nMsgLen As Long, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function HASH_HexFromFile Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strFileName As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function HASH_Bytes Lib "diCrPKI.dll" (ByRef lpDigest As Byte, ByVal nDigLen As Long, ByRef lpMessage As Byte, ByVal nMsgLen As Long, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function HASH_File Lib "diCrPKI.dll" (ByRef lpDigest As Byte, ByVal nDigLen As Long, ByVal strFileName As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function HASH_HexFromHex Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nMaxChars As Long, ByVal strMsgHex As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function HASH_Length Lib "diCrPKI.dll" (ByVal nAlgId As Long) As Long
        
    ' HMAC FUNCTIONS
    Public Declare PtrSafe Function HMAC_Bytes Lib "diCrPKI.dll" (ByRef lpDigest As Byte, ByVal nDigLen As Long, ByRef lpMessage As Byte, ByVal nMsgLen As Long, ByRef lpKey As Byte, ByVal nKeyLen As Long, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function HMAC_HexFromBytes Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByRef lpMessage As Byte, ByVal nMsgLen As Long, ByRef lpKey As Byte, ByVal nKeyLen As Long, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function HMAC_HexFromHex Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strMsgHex As String, ByVal strKeyHex As String, ByVal nOptions As Long) As Long
    
    ' ENCODING CONVERSION FUNCTIONS
    ' (See cnv* Functions below for VBA-friendly versions of these)
    Public Declare PtrSafe Function CNV_HexStrFromBytes Lib "diCrPKI.dll" (ByVal strHex As String, ByVal nHexStrLen As Long, ByRef lpData As Byte, ByVal nDataLen As Long) As Long
    Public Declare PtrSafe Function CNV_BytesFromHexStr Lib "diCrPKI.dll" (ByRef lpData As Byte, ByVal nDataLen As Long, ByVal strHex As String) As Long
    Public Declare PtrSafe Function CNV_HexFilter Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal strInput As String, ByVal nStrLen As Long) As Long
    Public Declare PtrSafe Function CNV_B64StrFromBytes Lib "diCrPKI.dll" (ByVal strB64 As String, ByVal nB64StrLen As Long, ByRef lpData As Byte, ByVal nDataLen As Long) As Long
    Public Declare PtrSafe Function CNV_BytesFromB64Str Lib "diCrPKI.dll" (ByRef lpData As Byte, ByVal nDataLen As Long, ByVal strB64 As String) As Long
    Public Declare PtrSafe Function CNV_B64Filter Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal strInput As String, ByVal nStrLen As Long) As Long
    
    ' BASE58 FUNCTIONS
    ' Added [v11.0]
    Public Declare PtrSafe Function CNV_Base58FromBytes Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByRef lpInput As Byte, ByVal nInputLen As Long) As Long
    Public Declare PtrSafe Function CNV_Base58ToBytes Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutBytes As Long, ByVal strInput As String) As Long
       
    ' UTF-8 CONVERSION/CHECK FUNCTIONS
    Public Declare PtrSafe Function CNV_UTF8BytesFromLatin1 Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutBytes As Long, ByVal strInput As String) As Long
    Public Declare PtrSafe Function CNV_Latin1FromUTF8Bytes Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByRef lpInput As Byte, ByVal nBytes As Long) As Long
    Public Declare PtrSafe Function CNV_CheckUTF8Bytes Lib "diCrPKI.dll" (ByRef lpInput As Byte, ByVal nBytes As Long) As Long
    Public Declare PtrSafe Function CNV_ByteEncoding Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutBytes As Long, ByRef lpInput As Byte, ByVal nBytes As Long, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function CNV_CheckUTF8File Lib "diCrPKI.dll" (ByVal strFileName As String) As Long
    
    ' The following three functions are @deprecated...
    Public Declare PtrSafe Function CNV_UTF8FromLatin1 Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strInput As String) As Long
    Public Declare PtrSafe Function CNV_Latin1FromUTF8 Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strInput As String) As Long
    Public Declare PtrSafe Function CNV_CheckUTF8 Lib "diCrPKI.dll" (ByVal strInput As String) As Long
    
    ' MISC BYTE UTILITIES
    ' Added [v11.0]
    Public Declare PtrSafe Function CNV_ReverseBytes Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByRef lpInput As Byte, ByVal nBytes As Long) As Long
    Public Declare PtrSafe Function CNV_NumToBytes Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutBytes As Long, ByVal nNumber As Long, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function CNV_NumFromBytes Lib "diCrPKI.dll" (ByRef lpInput As Byte, ByVal nBytes As Long, ByVal nOptions As Long) As Long
    
    ' PEM/BINARY FILE CONVERSIONS
    Public Declare PtrSafe Function PEM_FileFromBinFile Lib "diCrPKI.dll" (ByVal strOutputFile As String, ByVal strFileIn As String, ByVal strHeader As String, ByVal nLineLen As Long) As Long
    Public Declare PtrSafe Function PEM_FileFromBinFileEx Lib "diCrPKI.dll" (ByVal strFileOut As String, ByVal strFileIn As String, ByVal strHeader As String, ByVal nLineLen As Long, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function PEM_FileToBinFile Lib "diCrPKI.dll" (ByVal strOutputFile As String, ByVal strFileIn As String) As Long
    
    ' ERROR FUNCTIONS
    Public Declare PtrSafe Function PKI_LastError Lib "diCrPKI.dll" (ByVal strErrMsg As String, ByVal nMaxMsgLen As Long) As Long
    Public Declare PtrSafe Function PKI_ErrorCode Lib "diCrPKI.dll" () As Long
    Public Declare PtrSafe Function PKI_ErrorLookup Lib "diCrPKI.dll" (ByVal strErrMsg As String, ByVal nMaxMsgLen As Long, ByVal nErrorCode As Long) As Long
    Public Declare PtrSafe Function PKI_PowerUpTests Lib "diCrPKI.dll" (ByVal nOptions As Long) As Long
        
    ' GENERAL DIAGNOSTIC FUNCTIONS
    Public Declare PtrSafe Function PKI_Version Lib "diCrPKI.dll" (ByVal nReserved1 As Long, ByVal nReserved2 As Long) As Long
    Public Declare PtrSafe Function PKI_LicenceType Lib "diCrPKI.dll" (ByVal nReserved As Long) As Long
    Public Declare PtrSafe Function PKI_CompileTime Lib "diCrPKI.dll" (ByVal strCompiledOn As String, ByVal nStrLen As Long) As Long
    Public Declare PtrSafe Function PKI_ModuleName Lib "diCrPKI.dll" (ByVal strModuleName As String, ByVal nStrLen As Long, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function PKI_Platform Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long) As Long
    ' New in [v12.4]
    Public Declare PtrSafe Function PKI_ModuleInfo Lib "diCrPKI.dll" (ByVal strModuleName As String, ByVal nStrLen As Long, ByVal nOptions As Long) As Long
        
    ' RNG FUNCTIONS
    Public Declare PtrSafe Function RNG_Bytes Lib "diCrPKI.dll" (ByRef lpData As Byte, ByVal nDataLen As Long, ByVal strSeed As String, ByVal nSeedLen As Long) As Long
    ' Alternative alias of RNG_Bytes to write to an ANSI string (VB6/VBA only)...
    Public Declare PtrSafe Function RNG_String Lib "diCrPKI.dll" Alias "RNG_Bytes" (ByVal strData As String, ByVal nDataLen As Long, ByVal strSeed As String, ByVal nSeedLen As Long) As Long
    Public Declare PtrSafe Function RNG_Number Lib "diCrPKI.dll" (ByVal nLower As Long, ByVal nUpper As Long) As Long
    Public Declare PtrSafe Function RNG_BytesWithPrompt Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutputLen As Long, ByVal strPrompt As String, ByVal nOptions As Long) As Long
    ' Alternative alias of RNG_BytesWithPrompt to write to an ANSI string (VB6/VBA only)...
    Public Declare PtrSafe Function RNG_StringWithPrompt Lib "diCrPKI.dll" Alias "RNG_BytesWithPrompt" (ByVal strData As String, ByVal nDataLen As Long, ByVal strPrompt As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function RNG_Initialize Lib "diCrPKI.dll" (ByVal strSeedFile As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function RNG_MakeSeedFile Lib "diCrPKI.dll" (ByVal strSeedFile As String, ByVal strPrompt As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function RNG_UpdateSeedFile Lib "diCrPKI.dll" (ByVal strSeedFile As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function RNG_Test Lib "diCrPKI.dll" (ByVal strFileName As String, ByVal nOptions As Long) As Long
    ' New in [v12.3]
    Public Declare PtrSafe Function RNG_Guid Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal nOptions As Long) As Long
    
    ' PASSWORD PROMPT FUNCTIONS
    Public Declare PtrSafe Function PWD_Prompt Lib "diCrPKI.dll" (ByVal strPassword As String, ByVal nPwdlen As Long, ByVal strCaption As String) As Long
    Public Declare PtrSafe Function PWD_PromptEx Lib "diCrPKI.dll" (ByVal strPassword As String, ByVal nPwdlen As Long, ByVal strCaption As String, ByVal strPrompt As String, ByVal nOptions As Long) As Long
    
    ' WIPE FUNCTIONS
    Public Declare PtrSafe Function WIPE_File Lib "diCrPKI.dll" (ByVal strFileName As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function WIPE_Data Lib "diCrPKI.dll" (ByRef lpData As Byte, ByVal nBytes As Long) As Long
    ' Alternative aliases of WIPE_Data to cope with Byte and String types explicitly (VB6/VBA only)...
    Public Declare PtrSafe Function WIPE_Bytes Lib "diCrPKI.dll" Alias "WIPE_Data" (ByRef lpData As Byte, ByVal nBytes As Long) As Long
    Public Declare PtrSafe Function WIPE_String Lib "diCrPKI.dll" Alias "WIPE_Data" (ByVal strData As String, ByVal nStrLen As Long) As Long
    
    ' PADDING FUNCTIONS
    Public Declare PtrSafe Function PAD_BytesBlock Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutputLen As Long, ByRef lpInput As Byte, ByVal nInputLen As Long, ByVal nBlockLen As Long, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function PAD_UnpadBytes Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutputLen As Long, ByRef lpInput As Byte, ByVal nInputLen As Long, ByVal nBlockLen As Long, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function PAD_HexBlock Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nMaxChars As Long, ByVal strInputHex As String, ByVal nBlockLen As Long, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function PAD_UnpadHex Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nMaxChars As Long, ByVal strInputHex As String, ByVal nBlockLen As Long, ByVal nOptions As Long) As Long
    
    ' PASSWORD-BASED KEY DERIVATION FUNCTIONS
    Public Declare PtrSafe Function PBE_Kdf2 Lib "diCrPKI.dll" (ByRef lpKey As Byte, ByVal nKeyBytes As Long, ByRef lpPwd As Byte, ByVal nPwdBytes As Long, ByRef lpSalt As Byte, ByVal nSaltBytes As Long, ByVal nCount As Long, ByVal nReserved As Long) As Long
    Public Declare PtrSafe Function PBE_Kdf2Hex Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nMaxChars As Long, ByVal nKeyBytes As Long, ByVal strPwd As String, ByVal strSaltHex As String, ByVal nCount As Long, ByVal nReserved As Long) As Long
    
    ' ASN.1 UTILITIES
    Public Declare PtrSafe Function ASN1_TextDump Lib "diCrPKI.dll" (ByVal strFileOut As String, ByVal strFileOrPEMString As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function ASN1_Type Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strFileOrPEMString As String, ByVal nOptions As Long) As Long
    ' New in [v12.0]
    Public Declare PtrSafe Function ASN1_TextDumpToString Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strFileOrPEMString As String, ByVal strDirName As String, ByVal nOptions As Long) As Long
    
    ' SIGNATURE FUNCTIONS
    Public Declare PtrSafe Function SIG_SignData Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByRef lpData As Byte, ByVal nDataLen As Long, ByVal strKeyFile As String, ByVal strPassword As String, ByVal strAlgName As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function SIG_SignFile Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strDataFile As String, ByVal strKeyFile As String, ByVal strPassword As String, ByVal strAlgName As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function SIG_VerifyData Lib "diCrPKI.dll" (ByVal strSignature As String, ByRef lpData As Byte, ByVal nDataLen As Long, ByVal strCertOrKeyFile As String, ByVal strAlgName As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function SIG_VerifyFile Lib "diCrPKI.dll" (ByVal strSignature As String, ByVal strDataFile As String, ByVal strCertOrKeyFile As String, ByVal strAlgName As String, ByVal nOptions As Long) As Long
    
    ' S/MIME FUNCTIONS
    Public Declare PtrSafe Function SMIME_Wrap Lib "diCrPKI.dll" (ByVal strFileOut As String, ByVal strFileIn As String, ByVal strFeatures As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function SMIME_Extract Lib "diCrPKI.dll" (ByVal strFileOut As String, ByVal strFileIn As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function SMIME_Query Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strFileIn As String, ByVal strQuery As String, ByVal nOptions As Long) As Long
    
    ' COMPRESSION FUNCTIONS
    ' New in [v12.0]
    Public Declare PtrSafe Function COMPR_Compress Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutBytes As Long, ByRef lpInput As Byte, ByVal nInputLen As Long, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function COMPR_Uncompress Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutBytes As Long, ByRef lpInput As Byte, ByVal nInputLen As Long, ByVal nOptions As Long) As Long
    
    ' KEY DERIVATION FUNCTIONS
    ' New in [v20.5]
    Public Declare PtrSafe Function KDF_Bytes Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutBytes As Long, ByRef lpIKM As Byte, ByVal nIkmLen As Long, ByRef lpInfo As Byte, ByVal nInfoLen As Long, ByVal strParams As String, ByVal nOptions As Long) As Long
    Public Declare PtrSafe Function KDF_ForCms Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutBytes As Long, ByRef lpZZ As Byte, ByVal nZzLen As Long, ByRef lpUkm As Byte, ByVal nUkmLen As Long, ByVal strParams As String, ByVal nOptions As Long) As Long

#Else
    ' Declarations for VB6 and 32-bit Office
    
    ' CRYPTOGRAPHIC MESSAGE SYNTAX (CMS) FUNCTIONS
    Public Declare Function CMS_MakeEnvData Lib "diCrPKI.dll" (ByVal strFileOut As String, ByVal strFileIn As String, ByVal strCertList As String, ByVal strSeed As String, ByVal nSeedLen As Long, ByVal nOptions As Long) As Long
    Public Declare Function CMS_MakeEnvDataFromString Lib "diCrPKI.dll" (ByVal strFileOut As String, ByVal strDataIn As String, ByVal strCertList As String, ByVal strSeed As String, ByVal nSeedLen As Long, ByVal nOptions As Long) As Long
    Public Declare Function CMS_ReadEnvData Lib "diCrPKI.dll" (ByVal strFileOut As String, ByVal strFileIn As String, ByVal strCertFile As String, ByVal strPrivateKey As String, ByVal nOptions As Long) As Long
    Public Declare Function CMS_ReadEnvDataToString Lib "diCrPKI.dll" (ByVal strDataOut As String, ByVal nDataLen As Long, ByVal strFileIn As String, ByVal strCertFile As String, ByVal strPrivateKey As String, ByVal nOptions As Long) As Long
    Public Declare Function CMS_MakeSigData Lib "diCrPKI.dll" (ByVal strFileOut As String, ByVal strFileIn As String, ByVal strCertList As String, ByVal strPrivateKey As String, ByVal nOptions As Long) As Long
    Public Declare Function CMS_MakeSigDataFromString Lib "diCrPKI.dll" (ByVal strFileOut As String, ByVal strDataIn As String, ByVal strCertList As String, ByVal strPrivateKey As String, ByVal nOptions As Long) As Long
    Public Declare Function CMS_MakeSigDataFromSigValue Lib "diCrPKI.dll" (ByVal strFileOut As String, ByRef lpSigValue As Byte, ByVal nSigLen As Long, ByRef lpData As Byte, ByVal nDataLen As Long, ByVal strCertList As String, ByVal nOptions As Long) As Long
    Public Declare Function CMS_MakeDetachedSig Lib "diCrPKI.dll" (ByVal strFileOut As String, ByVal strHexDigest As String, ByVal strCertList As String, ByVal strPrivateKey As String, ByVal nOptions As Long) As Long
    Public Declare Function CMS_ReadSigData Lib "diCrPKI.dll" (ByVal strFileOut As String, ByVal strFileIn As String, ByVal nOptions As Long) As Long
    Public Declare Function CMS_ReadSigDataToString Lib "diCrPKI.dll" (ByVal strDataOut As String, ByVal nDataLen As Long, ByVal strFileIn As String, ByVal nOptions As Long) As Long
    Public Declare Function CMS_GetSigDataDigest Lib "diCrPKI.dll" (ByVal strHexDigest As String, ByVal nHexDigestLen As Long, ByVal strFileIn As String, ByVal strCertFile As String, ByVal nOptions As Long) As Long
    Public Declare Function CMS_VerifySigData Lib "diCrPKI.dll" (ByVal strFileIn As String, ByVal strCertFile As String, ByVal strHexDigest As String, ByVal nOptions As Long) As Long
    Public Declare Function CMS_QuerySigData Lib "diCrPKI.dll" (ByVal strDataOut As String, ByVal nDataLen As Long, ByVal strFileIn As String, ByVal strQuery As String, ByVal nOptions As Long) As Long
    Public Declare Function CMS_QueryEnvData Lib "diCrPKI.dll" (ByVal strDataOut As String, ByVal nDataOutLen As Long, ByVal strFileIn As String, ByVal strQuery As String, ByVal nOptions As Long) As Long
    ' New in [v10.0]
    Public Declare Function CMS_MakeComprData Lib "diCrPKI.dll" (ByVal strFileOut As String, ByVal strFileIn As String, ByVal nOptions As Long) As Long
    Public Declare Function CMS_ReadComprData Lib "diCrPKI.dll" (ByVal strFileOut As String, ByVal strFileIn As String, ByVal nOptions As Long) As Long
    ' New in [v12.2]
    Public Declare Function CMS_ReadEnvDataToBytes Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutBytes As Long, ByVal strFileIn As String, ByVal strCertFile As String, ByVal strPrivateKey As String, ByVal nOptions As Long) As Long
    Public Declare Function CMS_ReadSigDataToBytes Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutBytes As Long, ByVal strFileIn As String, ByVal nOptions As Long) As Long
    Public Declare Function CMS_MakeEnvDataFromBytes Lib "diCrPKI.dll" (ByVal strFileOut As String, ByRef lpInput As Byte, ByVal nInputLen As Long, ByVal strCertList As String, ByVal strSeed As String, ByVal nSeedLen As Long, ByVal nOptions As Long) As Long
    Public Declare Function CMS_MakeSigDataFromBytes Lib "diCrPKI.dll" (ByVal strFileOut As String, ByRef lpInput As Byte, ByVal nInputLen As Long, ByVal strCertList As String, ByVal strPrivateKey As String, ByVal nOptions As Long) As Long
    
    ' RSA PUBLIC KEY FUNCTIONS
    ' New in [v12.3]
    Public Declare Function RSA_MakeKeysXtd Lib "diCrPKI.dll" (ByVal strPubKeyFile As String, ByVal strPriKeyFile As String, ByVal strPassword As String, ByVal nBits As Long, ByVal nExpFermat As Long, ByVal strParams As String, ByVal nOptions As Long) As Long
    Public Declare Function RSA_SaveEncKey Lib "diCrPKI.dll" (ByVal strFileOut As String, ByVal strIntKeyString As String, ByVal strPassword As String, ByVal strParams As String, ByVal nOptions As Long) As Long
    
    Public Declare Function RSA_MakeKeys Lib "diCrPKI.dll" (ByVal strPubKeyFile As String, ByVal strPvkKeyFile As String, ByVal nBits As Long, ByVal nExpFermat As Long, ByVal nTests As Long, ByVal nCount As Long, ByVal strPassword As String, ByVal strSeed As String, ByVal nSeedLen As Long, ByVal nOptions As Long) As Long
    Public Declare Function RSA_SavePublicKey Lib "diCrPKI.dll" (ByVal strOutputFile As String, ByVal strPublicKey As String, ByVal nOptions As Long) As Long
    Public Declare Function RSA_SaveEncPrivateKey Lib "diCrPKI.dll" (ByVal strOutputFile As String, ByVal strPrivateKey As String, ByVal nCount As Long, ByVal strPassword As String, ByVal nOptions As Long) As Long
    Public Declare Function RSA_SavePrivateKeyInfo Lib "diCrPKI.dll" (ByVal strOutputFile As String, ByVal strPrivateKey As String, ByVal nOptions As Long) As Long
    Public Declare Function RSA_GetPrivateKeyFromPFX Lib "diCrPKI.dll" (ByVal strOutputFile As String, ByVal strPfxFile As String, ByVal nOptions As Long) As Long
    Public Declare Function RSA_ToXMLString Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutputLen As Long, ByVal strKeyString As String, ByVal nOptions As Long) As Long
    Public Declare Function RSA_ToXMLStringEx Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strKeyString As String, ByVal strPrefix As String, ByVal nOptions As Long) As Long
    Public Declare Function RSA_FromXMLString Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutputLen As Long, ByVal strXmlString As String, ByVal nOptions As Long) As Long
    Public Declare Function RSA_KeyBits Lib "diCrPKI.dll" (ByVal strKey As String) As Long
    Public Declare Function RSA_KeyBytes Lib "diCrPKI.dll" (ByVal strKey As String) As Long
    Public Declare Function RSA_CheckKey Lib "diCrPKI.dll" (ByVal strKey As String, ByVal nOptions As Long) As Long
    Public Declare Function RSA_KeyHashCode Lib "diCrPKI.dll" (ByVal strKeyString As String) As Long
    Public Declare Function RSA_KeyMatch Lib "diCrPKI.dll" (ByVal strPrivateKey As String, ByVal strPublicKey As String) As Long
    Public Declare Function RSA_PublicKeyFromPrivate Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strKeyString As String, ByVal nOptions As Long) As Long
    Public Declare Function RSA_ReadAnyPrivateKey Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strKeyFile As String, ByVal strPassword As String, ByVal nOptions As Long) As Long
    Public Declare Function RSA_ReadAnyPublicKey Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strKeyFile As String, ByVal nOptions As Long) As Long
    Public Declare Function RSA_KeyValue Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strKeyString As String, ByVal strFieldName As String, ByVal nOptions As Long) As Long
    
    ' The following five functions are @deprecated - prefer RSA_ReadAnyPrivateKey or RSA_ReadAnyPublicKey.
    Public Declare Function RSA_ReadEncPrivateKey Lib "diCrPKI.dll" (ByVal strPrivateKey As String, ByVal nKeyMaxLen As Long, ByVal strEpkFileName As String, ByVal strPassword As String, ByVal nOptions As Long) As Long
    Public Declare Function RSA_ReadPrivateKeyInfo Lib "diCrPKI.dll" (ByVal strPrivateKey As String, ByVal nKeyMaxLen As Long, ByVal strPriFileName As String, ByVal nOptions As Long) As Long
    Public Declare Function RSA_ReadPrivateKeyFromPFX Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strPfxFile As String, ByVal strPassword As String, ByVal nOptions As Long) As Long
    Public Declare Function RSA_ReadPublicKey Lib "diCrPKI.dll" (ByVal strPublicKey As String, ByVal nKeyMaxLen As Long, ByVal strKeyFileName As String, ByVal nOptions As Long) As Long
    Public Declare Function RSA_GetPublicKeyFromCert Lib "diCrPKI.dll" (ByVal strPublicKey As String, ByVal nKeyMaxLen As Long, ByVal strCertFileName As String, ByVal nOptions As Long) As Long
    
    ' "RAW" RSA ENCRYPTION/DECRYPTION FUNCTIONS
    Public Declare Function RSA_RawPublic Lib "diCrPKI.dll" (ByRef lpData As Byte, ByVal nDataLen As Long, ByVal strPublicKey As String, ByVal nOptions As Long) As Long
    Public Declare Function RSA_RawPrivate Lib "diCrPKI.dll" (ByRef lpData As Byte, ByVal nDataLen As Long, ByVal strPrivateKey As String, ByVal nOptions As Long) As Long
    Public Declare Function RSA_EncodeMsg Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutputLen As Long, ByRef lpMessage As Byte, ByVal nMsgLen As Long, ByVal nOptions As Long) As Long
    Public Declare Function RSA_DecodeMsg Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutputLen As Long, ByRef lpInput As Byte, ByVal nInputLen As Long, ByVal nOptions As Long) As Long
    ' New in [v12.0]
    Public Declare Function RSA_Encrypt Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutBytes As Long, ByRef lpInput As Byte, ByVal nInputLen As Long, ByVal strPublicKeyFile As String, ByVal strParameters As String, ByVal nOptions As Long) As Long
    Public Declare Function RSA_Decrypt Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutBytes As Long, ByRef lpInput As Byte, ByVal nInputLen As Long, ByVal strPrivateKeyFile As String, ByVal strPassword As String, ByVal strParameters As String, ByVal nOptions As Long) As Long
    
    ' ELLIPTIC CURVE CRYPTOGRAPHY FUNCTIONS
    ' New in [v11.0]
    Public Declare Function ECC_MakeKeys Lib "diCrPKI.dll" (ByVal strPubKeyFile As String, ByVal strPriKeyFile As String, ByVal strCurveName As String, ByVal strPassword As String, ByVal strParams As String, ByVal nOptions As Long) As Long
    Public Declare Function ECC_ReadKeyByCurve Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strHexKey As String, ByVal strCurveName As String, ByVal nOptions As Long) As Long
    Public Declare Function ECC_ReadPrivateKey Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strKeyFileOrString As String, ByVal strPassword As String, ByVal nOptions As Long) As Long
    Public Declare Function ECC_ReadPublicKey Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strKeyFileOrString As String, ByVal nOptions As Long) As Long
    Public Declare Function ECC_SaveEncKey Lib "diCrPKI.dll" (ByVal strFileOut As String, ByVal strIntKeyString As String, ByVal strPassword As String, ByVal strParams As String, ByVal nOptions As Long) As Long
    Public Declare Function ECC_SaveKey Lib "diCrPKI.dll" (ByVal strFileOut As String, ByVal strIntKeyString As String, ByVal nOptions As Long) As Long
    Public Declare Function ECC_PublicKeyFromPrivate Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strIntKeyString As String, ByVal nOptions As Long) As Long
    Public Declare Function ECC_QueryKey Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strIntKeyString As String, ByVal strQuery As String, ByVal nOptions As Long) As Long
    Public Declare Function ECC_KeyHashCode Lib "diCrPKI.dll" (ByVal strKeyString As String) As Long
    ' New in [v12.5]
    Public Declare Function ECC_DHSharedSecret Lib "diCrPKI.dll" (ByRef lpZZ As Byte, ByVal nOutBytes As Long, ByVal strIntPrivateKey As String, ByVal strIntPublicKey As String, ByVal nOptions As Long) As Long
    
    ' PFX (PKCS-12) FUNCTIONS
    Public Declare Function PFX_MakeFile Lib "diCrPKI.dll" (ByVal strOutputFile As String, ByVal strCertFile As String, ByVal strKeyFile As String, ByVal strPassword As String, ByVal strFriendlyName As String, ByVal nOptions As Long) As Long
    Public Declare Function PFX_VerifySig Lib "diCrPKI.dll" (ByVal strFileName As String, ByVal strPassword As String, ByVal nOptions As Long) As Long
        
    ' X.509 CERTIFICATE FUNCTIONS
    Public Declare Function X509_MakeCertSelf Lib "diCrPKI.dll" (ByVal strNewCertFile As String, ByVal strEPKFile As String, ByVal nCertNum As Long, ByVal nYearsValid As Long, ByVal strDistName As String, ByVal strExtensions As String, ByVal KeyUsageFlags As Long, ByVal strPassword As String, ByVal nOptions As Long) As Long
    Public Declare Function X509_MakeCert Lib "diCrPKI.dll" (ByVal strNewCertFile As String, ByVal strIssuerCertFile As String, ByVal strSubjectPubKeyFile As String, ByVal strIssuerPvkInfoFile As String, ByVal nCertNum As Long, ByVal nYearsValid As Long, ByVal strDistName As String, ByVal strExtensions As String, ByVal KeyUsageFlags As Long, ByVal strPassword As String, ByVal nOptions As Long) As Long
    Public Declare Function X509_CertRequest Lib "diCrPKI.dll" (ByVal strReqFile As String, ByVal strEPKFile As String, ByVal strDistName As String, ByVal strExtensions As String, ByVal strPassword As String, ByVal nOptions As Long) As Long
    Public Declare Function X509_VerifyCert Lib "diCrPKI.dll" (ByVal strCertToVerify As String, ByVal strIssuerCert As String, ByVal nOptions As Long) As Long
    Public Declare Function X509_CertThumb Lib "diCrPKI.dll" (ByVal strCertFile As String, ByVal strHexHash As String, ByVal nHexHashLen As Long, ByVal nOptions As Long) As Long
    Public Declare Function X509_CertIsValidNow Lib "diCrPKI.dll" (ByVal strCertFile As String, ByVal nOptions As Long) As Long
    Public Declare Function X509_CertIssuedOn Lib "diCrPKI.dll" (ByVal strCertFile As String, ByVal strOutput As String, ByVal nOutputLen As Long, ByVal nOptions As Long) As Long
    Public Declare Function X509_CertExpiresOn Lib "diCrPKI.dll" (ByVal strCertFile As String, ByVal strOutput As String, ByVal nOutputLen As Long, ByVal nOptions As Long) As Long
    Public Declare Function X509_CertSerialNumber Lib "diCrPKI.dll" (ByVal strCertFile As String, ByVal strOutput As String, ByVal nOutputLen As Long, ByVal nOptions As Long) As Long
    Public Declare Function X509_CertIssuerName Lib "diCrPKI.dll" (ByVal strCertFile As String, ByVal strOutput As String, ByVal nOutputLen As Long, ByVal strDelim As String, ByVal nOptions As Long) As Long
    Public Declare Function X509_CertSubjectName Lib "diCrPKI.dll" (ByVal strCertFile As String, ByVal strOutput As String, ByVal nOutputLen As Long, ByVal strDelim As String, ByVal nOptions As Long) As Long
    Public Declare Function X509_HashIssuerAndSN Lib "diCrPKI.dll" (ByVal strCertFile As String, ByVal strOutput As String, ByVal nOutputLen As Long, ByVal nOptions As Long) As Long
    Public Declare Function X509_GetCertFromP7Chain Lib "diCrPKI.dll" (ByVal strOutputFile As String, ByVal strP7cFile As String, ByVal nIndex As Long, ByVal nOptions As Long) As Long
    Public Declare Function X509_GetCertFromPFX Lib "diCrPKI.dll" (ByVal strOutputFile As String, ByVal strPfxFile As String, ByVal strPassword As String, ByVal nOptions As Long) As Long
    Public Declare Function X509_KeyUsageFlags Lib "diCrPKI.dll" (ByVal strCertFile As String) As Long
    Public Declare Function X509_QueryCert Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strFileIn As String, ByVal szQuery As String, ByVal nOptions As Long) As Long
    Public Declare Function X509_ReadStringFromFile Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strCertFile As String, ByVal nOptions As Long) As Long
    Public Declare Function X509_SaveFileFromString Lib "diCrPKI.dll" (ByVal strNewCertFile As String, ByVal strCertString As String, ByVal nOptions As Long) As Long
    Public Declare Function X509_TextDump Lib "diCrPKI.dll" (ByVal strFileOut As String, ByVal strCertFile As String, ByVal nOptions As Long) As Long
    Public Declare Function X509_ValidatePath Lib "diCrPKI.dll" (ByVal strCertListOrP7File As String, ByVal strTrustedCert As String, ByVal nOptions As Long) As Long
    ' New in [v12.0]
    Public Declare Function X509_TextDumpToString Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strCertFile As String, ByVal nOptions As Long) As Long
    ' New in [v12.1]
    Public Declare Function X509_ReadCertStringFromP7Chain Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strP7cFile As String, ByVal nIndex As Long, ByVal nOptions As Long) As Long
    Public Declare Function X509_ReadCertStringFromPFX Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strPfxFile As String, ByVal strPassword As String, ByVal nOptions As Long) As Long
    ' New in [v12.2]
    Public Declare Function X509_GetCertCountInP7Chain Lib "diCrPKI.dll" (ByVal strP7cFile As String, ByVal nOptions As Long) As Long
    
    ' X509 CRL FUNCTIONS
    Public Declare Function X509_MakeCRL Lib "diCrPKI.dll" (ByVal strCrlFile As String, ByVal strIssuerCert As String, ByVal strIssuerKeyFile As String, ByVal strPassword As String, ByVal strRevokedCertList As String, ByVal strExtensions As String, ByVal nOptions As Long) As Long
    Public Declare Function X509_CheckCertInCRL Lib "diCrPKI.dll" (ByVal strCertFile As String, ByVal strCrlFile As String, ByVal strCRLIssuerCert As String, ByVal strDate As String, ByVal nOptions As Long) As Long
    
    ' ONLINE CERTIFICATE STATUS PROTOCOL (OCSP) FUNCTIONS
    Public Declare Function OCSP_MakeRequest Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strIssuerCert As String, ByVal strCertFileOrSerialNum As String, ByVal strExtensions As String, ByVal nOptions As Long) As Long
    Public Declare Function OCSP_ReadResponse Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strResponseFile As String, ByVal strIssuerCert As String, ByVal strExtensions As String, ByVal nOptions As Long) As Long
    
    ' TRIPLE DATA ENCRYPTION ALGORITHM (TDEA/3DES/TRIPLE DES) BLOCK CIPHER FUNCTIONS
    ' [@deprecated - use CIPHER_ functions]
    Public Declare Function TDEA_BytesMode Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByRef lpInput As Byte, ByVal nDataLen As Long, ByRef lpKey As Byte, ByVal bEncrypt As Long, ByVal strMode As String, ByRef lpIV As Byte) As Long
    Public Declare Function TDEA_HexMode Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal strInput As String, ByVal strKey As String, ByVal bEncrypt As Long, ByVal strMode As String, ByVal strIV As String) As Long
    Public Declare Function TDEA_B64Mode Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal strInput As String, ByVal strKey As String, ByVal bEncrypt As Long, ByVal strMode As String, ByVal strIV As String) As Long
    Public Declare Function TDEA_File Lib "diCrPKI.dll" (ByVal strFileOut As String, ByVal strFileIn As String, ByRef lpKey As Byte, ByVal bEncrypt As Long, ByVal strMode As String, ByRef lpIV As Byte) As Long
    
    ' GENERIC BLOCK CIPHER FUNCTIONS
    Public Declare Function CIPHER_Hex Lib "diCrPKI.dll" (ByVal fEncrypt As Long, ByVal strOutput As String, ByVal nOutChars As Long, ByVal strData As String, ByVal strKey As String, ByVal strIV As String, ByVal strAlgAndMode As String, ByVal nOptions As Long) As Long
    Public Declare Function CIPHER_KeyWrap Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutBytes As Long, ByRef lpData As Byte, ByVal nDataLen As Long, ByRef lpKEK As Byte, ByVal nKekLen As Long, ByVal nOptions As Long) As Long
    Public Declare Function CIPHER_KeyUnwrap Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutBytes As Long, ByRef lpData As Byte, ByVal nDataLen As Long, ByRef lpKEK As Byte, ByVal nKekLen As Long, ByVal nOptions As Long) As Long
    ' [The following two functions are @deprecated]
    Public Declare Function CIPHER_Bytes Lib "diCrPKI.dll" (ByVal fEncrypt As Long, ByRef lpOutput As Byte, ByRef lpData As Byte, ByVal nDataLen As Long, ByRef lpKey As Byte, ByRef lpIV As Byte, ByVal strAlgAndMode As String, ByVal nOptions As Long) As Long
    Public Declare Function CIPHER_File Lib "diCrPKI.dll" (ByVal fEncrypt As Long, ByVal strFileOut As String, ByVal strFileIn As String, ByRef lpKey As Byte, ByRef lpIV As Byte, ByVal strAlgAndMode As String, ByVal nOptions As Long) As Long
    ' Added in [v20.2] (to get rid of that annoying 2)
    Public Declare Function CIPHER_EncryptBytes Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutBytes As Long, ByRef lpInput As Byte, ByVal nInputLen As Long, ByRef lpKey As Byte, ByVal nKeyLen As Long, ByRef lpIV As Byte, ByVal nIVLen As Long, ByVal strAlgModePad As String, ByVal nOptions As Long) As Long
    Public Declare Function CIPHER_DecryptBytes Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutBytes As Long, ByRef lpInput As Byte, ByVal nInputLen As Long, ByRef lpKey As Byte, ByVal nKeyLen As Long, ByRef lpIV As Byte, ByVal nIVLen As Long, ByVal strAlgModePad As String, ByVal nOptions As Long) As Long
    ' Aliases for backwards compatibility
    Public Declare Function CIPHER_EncryptBytes2 Lib "diCrPKI.dll" Alias "CIPHER_EncryptBytes" (ByRef lpOutput As Byte, ByVal nOutBytes As Long, ByRef lpInput As Byte, ByVal nInputLen As Long, ByRef lpKey As Byte, ByVal nKeyLen As Long, ByRef lpIV As Byte, ByVal nIVLen As Long, ByVal strAlgModePad As String, ByVal nOptions As Long) As Long
    Public Declare Function CIPHER_DecryptBytes2 Lib "diCrPKI.dll" Alias "CIPHER_DecryptBytes" (ByRef lpOutput As Byte, ByVal nOutBytes As Long, ByRef lpInput As Byte, ByVal nInputLen As Long, ByRef lpKey As Byte, ByVal nKeyLen As Long, ByRef lpIV As Byte, ByVal nIVLen As Long, ByVal strAlgModePad As String, ByVal nOptions As Long) As Long
    Public Declare Function CIPHER_FileEncrypt Lib "diCrPKI.dll" (ByVal strFileOut As String, ByVal strFileIn As String, ByRef lpKey As Byte, ByVal nKeyLen As Long, ByRef lpIV As Byte, ByVal nIVLen As Long, ByVal strAlgModePad As String, ByVal nOptions As Long) As Long
    Public Declare Function CIPHER_FileDecrypt Lib "diCrPKI.dll" (ByVal strFileOut As String, ByVal strFileIn As String, ByRef lpKey As Byte, ByVal nKeyLen As Long, ByRef lpIV As Byte, ByVal nIVLen As Long, ByVal strAlgModePad As String, ByVal nOptions As Long) As Long
    ' New in [v12.1]
    Public Declare Function CIPHER_EncryptAEAD Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutBytes As Long, ByRef lpInput As Byte, ByVal nInputLen As Long, ByRef lpKey As Byte, ByVal nKeyLen As Long, ByRef lpIV As Byte, ByVal nIVLen As Long, ByRef lpAAD As Byte, ByVal nAadLen As Long, ByVal nOptions As Long) As Long
    Public Declare Function CIPHER_DecryptAEAD Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutBytes As Long, ByRef lpInput As Byte, ByVal nInputLen As Long, ByRef lpKey As Byte, ByVal nKeyLen As Long, ByRef lpIV As Byte, ByVal nIVLen As Long, ByRef lpAAD As Byte, ByVal nAadLen As Long, ByVal nOptions As Long) As Long
    ' New in [v12.5]
    Public Declare Function CIPHER_EncryptHex Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strInputHex As String, ByVal strKeyHex As String, ByVal strIvHex As String, ByVal strAlgModePad As String, ByVal nOptions As Long) As Long
    Public Declare Function CIPHER_DecryptHex Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strInputHex As String, ByVal strKeyHex As String, ByVal strIvHex As String, ByVal strAlgModePad As String, ByVal nOptions As Long) As Long
    
    ' MESSAGE DIGEST HASH FUNCTIONS
    Public Declare Function HASH_HexFromBytes Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByRef lpMessage As Byte, ByVal nMsgLen As Long, ByVal nOptions As Long) As Long
    ' Alternative alias of HASH_HexFromBytes to cope with ANSI strings (VB6/VBA only)...
    Public Declare Function HASH_HexFromString Lib "diCrPKI.dll" Alias "HASH_HexFromBytes" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strMessage As String, ByVal nMsgLen As Long, ByVal nOptions As Long) As Long
    Public Declare Function HASH_HexFromFile Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strFileName As String, ByVal nOptions As Long) As Long
    Public Declare Function HASH_Bytes Lib "diCrPKI.dll" (ByRef lpDigest As Byte, ByVal nDigLen As Long, ByRef lpMessage As Byte, ByVal nMsgLen As Long, ByVal nOptions As Long) As Long
    Public Declare Function HASH_File Lib "diCrPKI.dll" (ByRef lpDigest As Byte, ByVal nDigLen As Long, ByVal strFileName As String, ByVal nOptions As Long) As Long
    Public Declare Function HASH_HexFromHex Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nMaxChars As Long, ByVal strMsgHex As String, ByVal nOptions As Long) As Long
    Public Declare Function HASH_Length Lib "diCrPKI.dll" (ByVal nAlgId As Long) As Long
    
    ' HMAC FUNCTIONS
    Public Declare Function HMAC_Bytes Lib "diCrPKI.dll" (ByRef lpDigest As Byte, ByVal nDigLen As Long, ByRef lpMessage As Byte, ByVal nMsgLen As Long, ByRef lpKey As Byte, ByVal nKeyLen As Long, ByVal nOptions As Long) As Long
    Public Declare Function HMAC_HexFromBytes Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByRef lpMessage As Byte, ByVal nMsgLen As Long, ByRef lpKey As Byte, ByVal nKeyLen As Long, ByVal nOptions As Long) As Long
    Public Declare Function HMAC_HexFromHex Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strMsgHex As String, ByVal strKeyHex As String, ByVal nOptions As Long) As Long
    
    ' ENCODING CONVERSION FUNCTIONS
    ' (See cnv* Functions below for VB6-friendly versions of these)
    Public Declare Function CNV_HexStrFromBytes Lib "diCrPKI.dll" (ByVal strHex As String, ByVal nHexStrLen As Long, ByRef lpData As Byte, ByVal nDataLen As Long) As Long
    Public Declare Function CNV_BytesFromHexStr Lib "diCrPKI.dll" (ByRef lpData As Byte, ByVal nDataLen As Long, ByVal strHex As String) As Long
    Public Declare Function CNV_HexFilter Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal strInput As String, ByVal nStrLen As Long) As Long
    Public Declare Function CNV_B64StrFromBytes Lib "diCrPKI.dll" (ByVal strB64 As String, ByVal nB64StrLen As Long, ByRef lpData As Byte, ByVal nDataLen As Long) As Long
    Public Declare Function CNV_BytesFromB64Str Lib "diCrPKI.dll" (ByRef lpData As Byte, ByVal nDataLen As Long, ByVal strB64 As String) As Long
    Public Declare Function CNV_B64Filter Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal strInput As String, ByVal nStrLen As Long) As Long
    
    ' BASE58 FUNCTIONS
    ' Added [v11.0]
    Public Declare Function CNV_Base58FromBytes Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByRef lpInput As Byte, ByVal nInputLen As Long) As Long
    Public Declare Function CNV_Base58ToBytes Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutBytes As Long, ByVal strInput As String) As Long
       
    ' UTF-8 CONVERSION/CHECK FUNCTIONS
    Public Declare Function CNV_UTF8BytesFromLatin1 Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutBytes As Long, ByVal strInput As String) As Long
    Public Declare Function CNV_Latin1FromUTF8Bytes Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByRef lpInput As Byte, ByVal nBytes As Long) As Long
    Public Declare Function CNV_CheckUTF8Bytes Lib "diCrPKI.dll" (ByRef lpInput As Byte, ByVal nBytes As Long) As Long
    Public Declare Function CNV_ByteEncoding Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutBytes As Long, ByRef lpInput As Byte, ByVal nBytes As Long, ByVal nOptions As Long) As Long
    Public Declare Function CNV_CheckUTF8File Lib "diCrPKI.dll" (ByVal strFileName As String) As Long
    
    ' The following three functions are @deprecated...
    Public Declare Function CNV_UTF8FromLatin1 Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strInput As String) As Long
    Public Declare Function CNV_Latin1FromUTF8 Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strInput As String) As Long
    Public Declare Function CNV_CheckUTF8 Lib "diCrPKI.dll" (ByVal strInput As String) As Long
    
    ' MISC BYTE UTILITIES
    ' Added [v11.0]
    Public Declare Function CNV_ReverseBytes Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByRef lpInput As Byte, ByVal nBytes As Long) As Long
    Public Declare Function CNV_NumToBytes Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutBytes As Long, ByVal nNumber As Long, ByVal nOptions As Long) As Long
    Public Declare Function CNV_NumFromBytes Lib "diCrPKI.dll" (ByRef lpInput As Byte, ByVal nBytes As Long, ByVal nOptions As Long) As Long
    
    ' PEM/BINARY FILE CONVERSIONS
    Public Declare Function PEM_FileFromBinFile Lib "diCrPKI.dll" (ByVal strOutputFile As String, ByVal strFileIn As String, ByVal strHeader As String, ByVal nLineLen As Long) As Long
    Public Declare Function PEM_FileFromBinFileEx Lib "diCrPKI.dll" (ByVal strFileOut As String, ByVal strFileIn As String, ByVal strHeader As String, ByVal nLineLen As Long, ByVal nOptions As Long) As Long
    Public Declare Function PEM_FileToBinFile Lib "diCrPKI.dll" (ByVal strOutputFile As String, ByVal strFileIn As String) As Long
    
    ' ERROR FUNCTIONS
    Public Declare Function PKI_LastError Lib "diCrPKI.dll" (ByVal strErrMsg As String, ByVal nMaxMsgLen As Long) As Long
    Public Declare Function PKI_ErrorCode Lib "diCrPKI.dll" () As Long
    Public Declare Function PKI_ErrorLookup Lib "diCrPKI.dll" (ByVal strErrMsg As String, ByVal nMaxMsgLen As Long, ByVal nErrorCode As Long) As Long
    Public Declare Function PKI_PowerUpTests Lib "diCrPKI.dll" (ByVal nOptions As Long) As Long
        
    ' GENERAL DIAGNOSTIC FUNCTIONS
    Public Declare Function PKI_Version Lib "diCrPKI.dll" (ByVal nReserved1 As Long, ByVal nReserved2 As Long) As Long
    Public Declare Function PKI_LicenceType Lib "diCrPKI.dll" (ByVal nReserved As Long) As Long
    Public Declare Function PKI_CompileTime Lib "diCrPKI.dll" (ByVal strCompiledOn As String, ByVal nStrLen As Long) As Long
    Public Declare Function PKI_ModuleName Lib "diCrPKI.dll" (ByVal strModuleName As String, ByVal nStrLen As Long, ByVal nOptions As Long) As Long
    Public Declare Function PKI_Platform Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long) As Long
    ' New in [v12.4]
    Public Declare Function PKI_ModuleInfo Lib "diCrPKI.dll" (ByVal strModuleName As String, ByVal nStrLen As Long, ByVal nOptions As Long) As Long
        
    ' RNG FUNCTIONS
    Public Declare Function RNG_Bytes Lib "diCrPKI.dll" (ByRef lpData As Byte, ByVal nDataLen As Long, ByVal strSeed As String, ByVal nSeedLen As Long) As Long
    ' Alternative alias of RNG_Bytes to write to an ANSI string (VB6/VBA only)...
    Public Declare Function RNG_String Lib "diCrPKI.dll" Alias "RNG_Bytes" (ByVal strData As String, ByVal nDataLen As Long, ByVal strSeed As String, ByVal nSeedLen As Long) As Long
    Public Declare Function RNG_Number Lib "diCrPKI.dll" (ByVal nLower As Long, ByVal nUpper As Long) As Long
    Public Declare Function RNG_BytesWithPrompt Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutputLen As Long, ByVal strPrompt As String, ByVal nOptions As Long) As Long
    ' Alternative alias of RNG_BytesWithPrompt to write to an ANSI string (VB6/VBA only)...
    Public Declare Function RNG_StringWithPrompt Lib "diCrPKI.dll" Alias "RNG_BytesWithPrompt" (ByVal strData As String, ByVal nDataLen As Long, ByVal strPrompt As String, ByVal nOptions As Long) As Long
    Public Declare Function RNG_Initialize Lib "diCrPKI.dll" (ByVal strSeedFile As String, ByVal nOptions As Long) As Long
    Public Declare Function RNG_MakeSeedFile Lib "diCrPKI.dll" (ByVal strSeedFile As String, ByVal strPrompt As String, ByVal nOptions As Long) As Long
    Public Declare Function RNG_UpdateSeedFile Lib "diCrPKI.dll" (ByVal strSeedFile As String, ByVal nOptions As Long) As Long
    Public Declare Function RNG_Test Lib "diCrPKI.dll" (ByVal strFileName As String, ByVal nOptions As Long) As Long
    ' New in [v12.3]
    Public Declare Function RNG_Guid Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal nOptions As Long) As Long
    
    ' PASSWORD PROMPT FUNCTIONS
    Public Declare Function PWD_Prompt Lib "diCrPKI.dll" (ByVal strPassword As String, ByVal nPwdlen As Long, ByVal strCaption As String) As Long
    Public Declare Function PWD_PromptEx Lib "diCrPKI.dll" (ByVal strPassword As String, ByVal nPwdlen As Long, ByVal strCaption As String, ByVal strPrompt As String, ByVal nOptions As Long) As Long
    
    ' WIPE FUNCTIONS
    Public Declare Function WIPE_File Lib "diCrPKI.dll" (ByVal strFileName As String, ByVal nOptions As Long) As Long
    Public Declare Function WIPE_Data Lib "diCrPKI.dll" (ByRef lpData As Byte, ByVal nBytes As Long) As Long
    ' Alternative aliases of WIPE_Data to cope with Byte and String types explicitly (VB6/VBA only)...
    Public Declare Function WIPE_Bytes Lib "diCrPKI.dll" Alias "WIPE_Data" (ByRef lpData As Byte, ByVal nBytes As Long) As Long
    Public Declare Function WIPE_String Lib "diCrPKI.dll" Alias "WIPE_Data" (ByVal strData As String, ByVal nStrLen As Long) As Long
    
    ' PADDING FUNCTIONS
    Public Declare Function PAD_BytesBlock Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutputLen As Long, ByRef lpInput As Byte, ByVal nInputLen As Long, ByVal nBlockLen As Long, ByVal nOptions As Long) As Long
    Public Declare Function PAD_UnpadBytes Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutputLen As Long, ByRef lpInput As Byte, ByVal nInputLen As Long, ByVal nBlockLen As Long, ByVal nOptions As Long) As Long
    Public Declare Function PAD_HexBlock Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nMaxChars As Long, ByVal strInputHex As String, ByVal nBlockLen As Long, ByVal nOptions As Long) As Long
    Public Declare Function PAD_UnpadHex Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nMaxChars As Long, ByVal strInputHex As String, ByVal nBlockLen As Long, ByVal nOptions As Long) As Long
    
    ' PASSWORD-BASED KEY DERIVATION FUNCTIONS
    Public Declare Function PBE_Kdf2 Lib "diCrPKI.dll" (ByRef lpKey As Byte, ByVal nKeyBytes As Long, ByRef lpPwd As Byte, ByVal nPwdBytes As Long, ByRef lpSalt As Byte, ByVal nSaltBytes As Long, ByVal nCount As Long, ByVal nReserved As Long) As Long
    Public Declare Function PBE_Kdf2Hex Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nMaxChars As Long, ByVal nKeyBytes As Long, ByVal strPwd As String, ByVal strSaltHex As String, ByVal nCount As Long, ByVal nReserved As Long) As Long
    
    ' ASN.1 UTILITIES
    Public Declare Function ASN1_TextDump Lib "diCrPKI.dll" (ByVal strFileOut As String, ByVal strFileOrPEMString As String, ByVal nOptions As Long) As Long
    Public Declare Function ASN1_Type Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strFileOrPEMString As String, ByVal nOptions As Long) As Long
    ' New in [v12.0]
    Public Declare Function ASN1_TextDumpToString Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strFileOrPEMString As String, ByVal strDirName As String, ByVal nOptions As Long) As Long
    
    ' SIGNATURE FUNCTIONS
    Public Declare Function SIG_SignData Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByRef lpData As Byte, ByVal nDataLen As Long, ByVal strKeyFile As String, ByVal strPassword As String, ByVal strAlgName As String, ByVal nOptions As Long) As Long
    Public Declare Function SIG_SignFile Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strDataFile As String, ByVal strKeyFile As String, ByVal strPassword As String, ByVal strAlgName As String, ByVal nOptions As Long) As Long
    Public Declare Function SIG_VerifyData Lib "diCrPKI.dll" (ByVal strSignature As String, ByRef lpData As Byte, ByVal nDataLen As Long, ByVal strCertOrKeyFile As String, ByVal strAlgName As String, ByVal nOptions As Long) As Long
    Public Declare Function SIG_VerifyFile Lib "diCrPKI.dll" (ByVal strSignature As String, ByVal strDataFile As String, ByVal strCertOrKeyFile As String, ByVal strAlgName As String, ByVal nOptions As Long) As Long
    
    ' S/MIME FUNCTIONS
    Public Declare Function SMIME_Wrap Lib "diCrPKI.dll" (ByVal strFileOut As String, ByVal strFileIn As String, ByVal strFeatures As String, ByVal nOptions As Long) As Long
    Public Declare Function SMIME_Extract Lib "diCrPKI.dll" (ByVal strFileOut As String, ByVal strFileIn As String, ByVal nOptions As Long) As Long
    Public Declare Function SMIME_Query Lib "diCrPKI.dll" (ByVal strOutput As String, ByVal nOutChars As Long, ByVal strFileIn As String, ByVal strQuery As String, ByVal nOptions As Long) As Long
    
    ' COMPRESSION FUNCTIONS
    ' New in [v12.0]
    Public Declare Function COMPR_Compress Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutBytes As Long, ByRef lpInput As Byte, ByVal nInputLen As Long, ByVal nOptions As Long) As Long
    Public Declare Function COMPR_Uncompress Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutBytes As Long, ByRef lpInput As Byte, ByVal nInputLen As Long, ByVal nOptions As Long) As Long
    
    ' KEY DERIVATION FUNCTIONS
    ' New in [v20.5]
    Public Declare Function KDF_Bytes Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutBytes As Long, ByRef lpIKM As Byte, ByVal nIkmLen As Long, ByRef lpInfo As Byte, ByVal nInfoLen As Long, ByVal strParams As String, ByVal nOptions As Long) As Long
    Public Declare Function KDF_ForCms Lib "diCrPKI.dll" (ByRef lpOutput As Byte, ByVal nOutBytes As Long, ByRef lpZZ As Byte, ByVal nZzLen As Long, ByRef lpUkm As Byte, ByVal nUkmLen As Long, ByVal strParams As String, ByVal nOptions As Long) As Long

#End If

' *** END OF CRYPTOSYS PKI DECLARATIONS
'**************************************

' *****************
' WRAPPER FUNCTIONS
' *****************
' Direct calls to the DLL begin with "XXX_", wrapper functions begin with "xxx"

' To create an empty Byte array, say for lpIV or lpAAD,
' assign `vbNullString` to the variable. For example,
'    Dim lpIV() As Byte
'    lpIV = vbNullString   ' Set to empty array
'    lpCipher = cipherEncryptBytes(lpPlain, lpKey, lpIV, "Aes128/ECB")

'--------------------
' UTILITY FUNCTION
'--------------------
'/**
' Find length of byte array.
' @param  ab Input byte array.
' @return Number of bytes in array.
' @remark Safe to use even if array is empty.
' @example
' {@code
' Dim ab() As Byte
' Debug.Print cnvBytesLen(ab) ' Expecting 0
' ReDim ab(10)    ' NB actually 11 elements (0..10)
' Debug.Print cnvBytesLen(ab) ' 11
' ab = vbNullString   ' Set to empty array
' Debug.Print cnvBytesLen(ab) ' 0
' }
'**/
Public Function cnvBytesLen(ab() As Byte) As Long
    ' Trap error if array is empty
    On Error Resume Next
    cnvBytesLen = UBound(ab) - LBound(ab) + 1
End Function

'/**
' Encode an array of bytes as a hexadecimal-encoded string.
' @param lpData Input byte array.
' @return Hexadecimal-encoded string.
' @remark Same as {@link cnvToHex}.
'**/
Public Function cnvHexStrFromBytes(lpData() As Byte) As String
    Dim strHex As String
    Dim nHexLen As Long
    Dim nDataLen As Long
    
    nDataLen = cnvBytesLen(lpData)
    If nDataLen = 0 Then Exit Function
    nHexLen = CNV_HexStrFromBytes(vbNullString, 0, lpData(0), nDataLen)
    If nHexLen <= 0 Then
        Exit Function
    End If
    strHex = String$(nHexLen, " ")
    nHexLen = CNV_HexStrFromBytes(strHex, nHexLen, lpData(0), nDataLen)
    If nHexLen <= 0 Then
        Exit Function
    End If
    cnvHexStrFromBytes = Left$(strHex, nHexLen)
End Function

'/**
' Encode an ANSI string as a hexadecimal-encoded string.
' @param szData String to be encoded.
' @return Hexadecimal-encoded string.
' @remark Expecting a string of 8-bit "ANSI" characters.
'**/
Public Function cnvHexStrFromString(szData As String) As String
    Dim strHex As String
    Dim nHexLen As Long
    Dim nDataLen As Long
    Dim abData() As Byte
    
    If Len(szData) = 0 Then Exit Function
    abData = StrConv(szData, vbFromUnicode)
    nDataLen = cnvBytesLen(abData)
    nHexLen = CNV_HexStrFromBytes(vbNullString, 0, abData(0), nDataLen)
    If nHexLen <= 0 Then
        Exit Function
    End If
    strHex = String$(nHexLen, " ")
    nHexLen = CNV_HexStrFromBytes(strHex, nHexLen, abData(0), nDataLen)
    If nHexLen <= 0 Then
        Exit Function
    End If
    cnvHexStrFromString = Left$(strHex, nHexLen)
End Function

'/**
' Decode a hexadecimal-encoded string as an array of Bytes.
' @param szHex Hexadecimal data to be decoded.
' @return Binary data in byte array, or an empty array on error.
' @remark Same as {@link cnvFromHex}.
'**/
Public Function cnvBytesFromHexStr(szHex As String) As Byte()
    Dim abData() As Byte
    Dim nDataLen As Long
    
    ' Set default return value that won't cause a run-time error
    cnvBytesFromHexStr = vbNullString
    nDataLen = CNV_BytesFromHexStr(0, 0, szHex)
    If nDataLen <= 0 Then
        Exit Function
    End If
    ReDim abData(nDataLen - 1)
    nDataLen = CNV_BytesFromHexStr(abData(0), nDataLen, szHex)
    If nDataLen <= 0 Then
        Exit Function
    End If
    ReDim Preserve abData(nDataLen - 1)
    cnvBytesFromHexStr = abData
End Function

'/**
' Decode a hexadecimal-encoded string as an ANSI string.
' @param szHex Hexadecimal data to be decoded.
' @return Decoded string. For example, "6162632E" will be converted to "abc."
' @remark Output is a string of "ANSI" characters of value between 0 and 255.
'**/
Public Function cnvStringFromHexStr(ByVal szHex As String) As String
    Dim abData() As Byte
    If Len(szHex) = 0 Then Exit Function
    abData = cnvBytesFromHexStr(szHex)
    cnvStringFromHexStr = StrConv(abData, vbUnicode)
End Function

'/**
' Strip any invalid hex characters from a hex string.
' @param szHex String to be filtered.
' @return Filtered string.
'**/
Public Function cnvHexFilter(szHex As String) As String
    Dim strFiltered As String
    Dim nLen As Long
    
    strFiltered = String(Len(szHex), " ")
    nLen = CNV_HexFilter(strFiltered, szHex, Len(szHex))
    If nLen > 0 Then
        strFiltered = Left$(strFiltered, nLen)
    Else
        strFiltered = ""
    End If
    cnvHexFilter = strFiltered
End Function

'/**
' Encode an array of bytes as a base64-encoded string.
' @param lpData Input byte array.
' @return Base64-encoded string.
' @remark Same as {@link cnvToBase64}.
'**/
Public Function cnvB64StrFromBytes(lpData() As Byte) As String
    Dim strB64 As String
    Dim nB64Len As Long
    Dim nDataLen As Long
    
    nDataLen = cnvBytesLen(lpData)
    If nDataLen = 0 Then Exit Function
    nB64Len = CNV_B64StrFromBytes(vbNullString, 0, lpData(0), nDataLen)
    If nB64Len <= 0 Then Exit Function
    strB64 = String$(nB64Len, " ")
    nB64Len = CNV_B64StrFromBytes(strB64, nB64Len, lpData(0), nDataLen)
    If nB64Len <= 0 Then Exit Function
    cnvB64StrFromBytes = Left$(strB64, nB64Len)
End Function

'/**
' Encode an ANSI string as a base64-encoded string.
' @param szData String to be encoded.
' @return Base64-encoded string.
' @remark Expecting a string of 8-bit "ANSI" characters.
'**/
Public Function cnvB64StrFromString(szData As String) As String
    Dim strB64 As String
    Dim nB64Len As Long
    Dim nDataLen As Long
    Dim abData() As Byte
    
    If Len(szData) = 0 Then Exit Function
    abData = StrConv(szData, vbFromUnicode)
    nDataLen = UBound(abData) - LBound(abData) + 1
    nB64Len = CNV_B64StrFromBytes(vbNullString, 0, abData(0), nDataLen)
    If nB64Len <= 0 Then Exit Function
    strB64 = String$(nB64Len, " ")
    nB64Len = CNV_B64StrFromBytes(strB64, nB64Len, abData(0), nDataLen)
    If nB64Len <= 0 Then Exit Function
    cnvB64StrFromString = Left$(strB64, nB64Len)
End Function

'/**
' Decode a base64-encoded string as an array of Bytes.
' @param szB64 Base64 data to be decoded.
' @return Binary data in byte array, or an empty array on error.
' @remark Same as {@link cnvFromBase64}.
'**/
Public Function cnvBytesFromB64Str(szB64 As String) As Byte()
    Dim abData() As Byte
    Dim nDataLen As Long
    
    ' Set default return value that won't cause a run-time error
    cnvBytesFromB64Str = vbNullString
    nDataLen = CNV_BytesFromB64Str(0, 0, szB64)
    If nDataLen <= 0 Then Exit Function
    ReDim abData(nDataLen - 1)
    nDataLen = CNV_BytesFromB64Str(abData(0), nDataLen, szB64)
    If nDataLen <= 0 Then Exit Function
    ReDim Preserve abData(nDataLen - 1)
    cnvBytesFromB64Str = abData
End Function

'/**
' Strip any invalid base64 characters from a string.
' @param szB64 String to be filtered.
' @return Filtered string.
'**/
Public Function cnvB64Filter(szB64 As String) As String
    Dim strFiltered As String
    Dim nLen As Long
    
    strFiltered = String(Len(szB64), " ")
    nLen = CNV_B64Filter(strFiltered, szB64, Len(szB64))
    If nLen > 0 Then
        strFiltered = Left$(strFiltered, nLen)
    Else
        strFiltered = ""
    End If
    cnvB64Filter = strFiltered
End Function

'/**
' Re-encode a hexadecimal-encoded binary value as base64.
' @param szHex Hex string representing a binary value.
' @return Binary value encoded in base64
'**/
Public Function cnvB64StrFromHexStr(szHex As String) As String
    cnvB64StrFromHexStr = cnvB64StrFromBytes(cnvBytesFromHexStr(szHex))
End Function

'/**
' Re-encode a base64-encoded binary value as hexadecimal.
' @param szB64 Base64 string representing a binary value.
' @return Binary value encoded in hexadecimal
'**/
Public Function cnvHexStrFromB64Str(szB64 As String) As String
    cnvHexStrFromB64Str = cnvHexStrFromBytes(cnvBytesFromB64Str(szB64))
End Function

'/**
' Encode a substring of an array of bytes as a hexadecimal-encoded string.
' @param abData Input byte array.
' @param nOffset Offset at which substring begins. First byte is at offset zero.
' @param nBytes Number of bytes in substring to encode.
' @return Hexadecimal-encoded string.
' @example
' {@code
' Debug.Print cnvHexFromBytesMid(cnvBytesFromHexStr("00112233445566"), 3, 2) ' 3344
' }
'**/
Public Function cnvHexFromBytesMid(abData() As Byte, nOffset As Long, nBytes As Long) As String
    Dim strHex As String
    ' Lazy but safe! Encode it all then grab the substring
    strHex = cnvHexStrFromBytes(abData)
    cnvHexFromBytesMid = Mid(strHex, nOffset * 2 + 1, nBytes * 2)
End Function

'/**
' Get error message associated with a given error code.
' @param nErrCode Error code for which the message is required.
' @return Error message, or empty string if no corresponding error code.
'**/
Public Function pkiErrorLookup(nErrCode As Long) As String
    Dim strMSG As String
    Dim nLen As Long
    
    nLen = PKI_MAX_ERRORLOOKUP_CHARS
    strMSG = String$(nLen, " ")
    nLen = PKI_ErrorLookup(strMSG, nLen, nErrCode)
    pkiErrorLookup = Left(strMSG, nLen)
End Function

'
' Get last error message set by previous function [DEPRECATED].
' @return Final error message from last call (may be empty).
' @deprecated Use {@link pkiLastError}.
'
Public Function pkiGetLastError() As String
    Dim strMSG As String
    Dim nLen As Long
    
    nLen = PKI_MAX_LASTERROR_CHARS
    strMSG = String$(nLen, " ")
    nLen = PKI_LastError(strMSG, nLen)
    pkiGetLastError = Left(strMSG, nLen)
End Function

'/**
' Prompt for a password in a dialog box.
' @param szCaption Caption for the dialog box
' @param szPrompt Wording for prompt (optional, default="Enter Password:")
' @return String containing password or empty string `""` if user cancels.
'**/
Public Function pwdPrompt(Optional szCaption As String = "", Optional szPrompt As String = "") As String
    Dim strPassword As String
    Dim nLen As Long
    
    nLen = 255
    strPassword = String(nLen, " ")
    nLen = PWD_PromptEx(strPassword, nLen, szCaption, szPrompt, 0)
    If nLen < 0 Then
        Exit Function
    ElseIf nLen > 0 Then
        pwdPrompt = Left(strPassword, nLen)
    End If
    ' Clean up local variable
    strPassword = wipeString(strPassword)
End Function

'/**
' Wipe a string securely and return an empty string.
' @param szToWipe String to be wiped.
' @return An empty string.
' @remark To use: `szToWipe = wipeString(szToWipe)`
' @example
' {@code
' Dim strData As String
' strData = "my deepest secrets"
' strData = wipeString(strData)
' }
'**/
Public Function wipeString(ByRef szToWipe As String) As String
    Call WIPE_String(szToWipe, Len(szToWipe))
    wipeString = ""
End Function

'/**
' Wipe a byte array securely.
' @param lpToWipe Byte array to be wiped.
' @return An empty byte array.
' @example
' {@code
' Dim lpData() As Byte
' lpData = cnvFromHex("DEADBEEF")
' Debug.Print "BEFORE: 0x(" & cnvToHex(lpData) & ")" ' BEFORE: 0x(DEADBEEF)
' Call wipeBytes(lpData)
' Debug.Print "AFTER: 0x(" & cnvToHex(lpData) & ")" ' AFTER: 0x()
' }
'**/
Public Function wipeBytes(ByRef lpToWipe() As Byte) As Byte()
    Call WIPE_Data(lpToWipe(0), UBound(lpToWipe) + 1)
    lpToWipe = vbNullString
    wipeBytes = vbNullString
End Function

'
' Add PKCS5 padding to a hex string up to next multiple of block length [DEPRECATED].
' @param strInputHex Hexadecimal-encoded data to be padded.
' @param nBlockLen Cipher block length in bytes (8 or 16).
' @return Padded hex string or empty string on error.
' @deprecated Use {@link padHexBlock}.
'
Public Function padHexString(ByVal strInputHex As String, nBlockLen As Long) As String
    Dim nOutChars As Long
    Dim strOutputHex As String
    ' In VB6 an uninitialised empty string is passed to a DLL as a NULL,
    ' so we append a non-null empty string!
    strInputHex = strInputHex & ""
    nOutChars = PAD_HexBlock("", 0, strInputHex, nBlockLen, 0)
    Debug.Print "Required length is " & nOutChars & " characters"
    ' Check for error
    If (nOutChars <= 0) Then Exit Function
    ' Pre-dimension output
    strOutputHex = String(nOutChars, " ")
    nOutChars = PAD_HexBlock(strOutputHex, Len(strOutputHex), strInputHex, nBlockLen, 0)
    If (nOutChars <= 0) Then Exit Function
    Debug.Print "Padded data='" & strOutputHex & "'"
    padHexString = strOutputHex
End Function

'
' Strip PKCS5 padding from a hex string [DEPRECATED].
' @param strInputHex Hexadecimal-encoded padded data.
' @param nBlockLen Cipher block length in bytes (8 or 16).
' @return  Unpadded data in hex string or _unchanged_ data on error.
' @remark An error is indicated by returning the _original_ data
' which will always be longer than the expected unpadded result.
' @deprecated Use `padUnpadHex()`.
'
Public Function unpadHexString(strInputHex As String, nBlockLen As Long) As String
    Dim nOutChars As Long
    Dim strOutputHex As String
    ' No need to query for length because we know the output will be shorter than input
    ' so make sure output is as long as the input
    strOutputHex = String(Len(strInputHex), " ")
    nOutChars = PAD_UnpadHex(strOutputHex, Len(strOutputHex), strInputHex, nBlockLen, 0)
    Debug.Print "Unpadded length is " & nOutChars & " characters"
    ' Check for error
    If (nOutChars < 0) Then
        ' Return unchanged input to indicate error
        unpadHexString = strInputHex
        Exit Function
    End If
    ' Re-dimension the output to the correct length
    strOutputHex = Left$(strOutputHex, nOutChars)
    Debug.Print "Unpadded data='" & strOutputHex & "'"
    unpadHexString = strOutputHex
End Function

'/**
' Read private key from a file or string containing a key into an "internal" public key string.
' @param szKeyFileOrString Name of file containing the key, or a string containing the key in PEM format or XML format.
' @param szPassword Password, if the key is encrypted, or `""` if not.
' @param  nOptions For future use.
' @return String containing an internal representation of the private key, or an empty string on error.
'**/
Public Function rsaReadPrivateKey(szKeyFileOrString As String, szPassword As String, Optional nOptions As Long = 0) As String
    Dim nChars As Long
    ' How long is PrivateKey string?
    nChars = RSA_ReadAnyPrivateKey("", 0, szKeyFileOrString, szPassword, nOptions)
    If nChars <= 0 Then
        Exit Function
    End If
    ' Pre-dimension the string to receive data
    rsaReadPrivateKey = String(nChars, " ")
    ' Read in the Private Key
    nChars = RSA_ReadAnyPrivateKey(rsaReadPrivateKey, nChars, szKeyFileOrString, szPassword, nOptions)
End Function

'/**
' Read public key from a file or string containing a key into an "internal" public key string.
' @param szKeyFileOrString Name of file containing the key, or a string containing the key in PEM format or XML format.
' @param  nOptions For future use.
' @return String containing an internal representation of the public key, or an empty string on error.
'**/
Public Function rsaReadPublicKey(szKeyFileOrString As String, Optional nOptions As Long = 0) As String
    Dim nChars As Long
    ' How long is key string?
    nChars = RSA_ReadAnyPublicKey("", 0, szKeyFileOrString, nOptions)
    If nChars <= 0 Then
        Exit Function
    End If
    ' Pre-dimension the string to receive data
    rsaReadPublicKey = String(nChars, " ")
    ' Read in the Public Key
    nChars = RSA_ReadAnyPublicKey(rsaReadPublicKey, nChars, szKeyFileOrString, nOptions)
End Function

Public Function rsaReadEncPrivateKey(strEPKFile As String, strPassword As String) As String
' Reads the private key from a PKCS-8 EncryptedPrivateKeyInfo file
' (as created by RSA_MakeKeys)
' Returns the key as a base64 string or an empty string on error
' @SUPERSEDED v10.0 by rsaReadPrivateKey
    Dim nLen As Long
    Dim lngRet As Long
    ' How long is PrivateKey string?
    nLen = RSA_ReadEncPrivateKey("", 0, strEPKFile, strPassword, 0)
    If nLen <= 0 Then
        Exit Function
    End If
    ' Pre-dimension the string to receive data
    rsaReadEncPrivateKey = String(nLen, " ")
    ' Read in the Private Key
    lngRet = RSA_ReadEncPrivateKey(rsaReadEncPrivateKey, nLen, strEPKFile, strPassword, 0)

End Function

Public Function rsaReadPrivateKeyInfo(strKeyFile As String) As String
' Like rsaReadPrivateKey but for an UNencrypted private key info file
' Returns the key as a base64 string or an empty string on error
' @SUPERSEDED v10.0 by rsaReadPrivateKey
    Dim lngKeyLen As Long
    Dim lngRet As Long
    Dim strKey As String
    ' How long is key string?
    lngKeyLen = RSA_ReadPrivateKeyInfo("", 0, strKeyFile, 0)
    If lngKeyLen <= 0 Then
        Exit Function
    End If
    ' Pre-dimension the string to receive data
    strKey = String(lngKeyLen, " ")
    ' Read in the Private Key
    lngRet = RSA_ReadPrivateKeyInfo(strKey, lngKeyLen, strKeyFile, 0)
    rsaReadPrivateKeyInfo = strKey

End Function

Public Function rsaGetPublicKeyFromCert(strCertFile As String) As String
' Reads the public key from an X.509 certificate file
' Returns the key as a base64 string or an empty string on error
' @SUPERSEDED v10.0 by rsaReadPublicKey
    Dim nLen As Long
    Dim lngRet As Long
    ' How long is key string?
    nLen = RSA_GetPublicKeyFromCert("", 0, strCertFile, 0)
    If nLen <= 0 Then
        Exit Function
    End If
    ' Pre-dimension the string to receive data
    rsaGetPublicKeyFromCert = String(nLen, " ")
    ' Read in the Private Key
    lngRet = RSA_GetPublicKeyFromCert(rsaGetPublicKeyFromCert, nLen, strCertFile, 0)

End Function


'/**
' Dump details of ASN.1 formatted data to a string.
' @param  szFileOrPEMString Filename of ASN.1 formatted data file to be analyzed (or its base64 representation or PEM string).
' @param  nOptions Use 0 for default or add any of:
' {@code
' PKI_ASN1_NOCOMMENTS
' PKI_ASN1_ADDLEVELS
' }
' @param  szDirName Directory in which to create a temporary file. Specify `""` for default = system `TEMP` directory.
' @return String containing the output.
' @remark Note different order of parameters from core function.
'**/
Public Function asn1TextDumpToString(szFileOrPEMString As String, Optional nOptions As Long = 0, Optional szDirName As String = "") As String
    ' NOTE changed order of parameters!
    Dim nc As Long
    nc = ASN1_TextDumpToString(vbNullString, 0, szFileOrPEMString, szDirName, nOptions)
    If nc <= 0 Then Exit Function
    asn1TextDumpToString = String(nc, " ")
    nc = ASN1_TextDumpToString(asn1TextDumpToString, nc, szFileOrPEMString, szDirName, nOptions)
    asn1TextDumpToString = Left$(asn1TextDumpToString, nc)
End Function

'/**
' Describe the type of ASN.1 data.
' @param  szFileOrPEMString Filename of ASN.1 formatted data file to be analyzed (or a string containing its base64 or PEM representation).
' @param  nOptions For future use.
' @return String containing the name of the type of ASN.1 data or the empty string if not found.
' @remark Possible return values:
' {@code
' "EC PRIVATE KEY"
' "OCSP REQUEST"
' "OCSP RESPONSE"
' "PKCS1 RSA PRIVATE KEY"
' "PKCS1 RSA PUBLIC KEY"
' "PKCS10 CERTIFICATE REQUEST"
' "PKCS12 PFX"
' "PKCS7 CERTIFICATE CHAIN"
' "PKCS7/CMS COMPRESSED DATA"
' "PKCS7/CMS DATA"
' "PKCS7/CMS ENVELOPED DATA"
' "PKCS7/CMS SIGNED DATA"
' "PKCS8 ENCRYPTED PRIVATE KEY"
' "PKCS8 PRIVATE KEY INFO"
' "PUBLIC KEY INFO"
' "X509 CERTIFICATE"
' "X509 CRL"
' }
'**/
Public Function asn1Type(szFileOrPEMString As String, Optional nOptions As Long = 0) As String
    Dim nc As Long
    nc = ASN1_Type(vbNullString, 0, szFileOrPEMString, nOptions)
    If nc <= 0 Then Exit Function
    asn1Type = String(nc, " ")
    nc = ASN1_Type(asn1Type, nc, szFileOrPEMString, nOptions)
    asn1Type = Left$(asn1Type, nc)
End Function

'/**
' Decrypt data using Authenticated Encryption with Associated Data (AEAD).
' The authentication tag is expected to be appended to the input ciphertext.
' @param  lpInput Input data to be decrypted.
' @param  lpKey Key of exact length for algorithm (16, 24 or 32 bytes).
' @param  lpIV Initialization Vector (IV) (aka nonce) exactly 12 bytes long.
' @param  lpAAD Additional authenticated data (optional) - set as null to ignore.
' @param  nOptions Algorithm to be used. Select one from
' {@code
' PKI_AEAD_AES_128_GCM
' PKI_AEAD_AES_192_GCM
' PKI_AEAD_AES_256_GCM
' }
' Add `PKI_IV_PREFIX` to expect the IV to be prepended at the start of the input.
' @return Plaintext in a byte array, or empty array on error (an empty array may also trivially be the correct result).
' @remark The input must include the 16-byte tag appended to the ciphertext.
'**/
Public Function cipherDecryptAEAD(lpInput() As Byte, lpKey() As Byte, lpIV() As Byte, lpAAD() As Byte, nOptions As Long) As Byte()
    cipherDecryptAEAD = vbNullString
    Dim n1 As Long
    n1 = cnvBytesLen(lpInput)
    If n1 = 0 Then Exit Function
    Dim n2 As Long
    n2 = cnvBytesLen(lpKey)
    If n2 = 0 Then Exit Function
    Dim n3 As Long
    n3 = cnvBytesLen(lpIV)
    If n3 = 0 Then Exit Function
    Dim n4 As Long
    n4 = cnvBytesLen(lpAAD)
    ' Fudge to allow an empty input array
    If n4 = 0 Then ReDim lpAAD(0)
    Dim abMyData() As Byte
    Dim nb As Long
    nb = CIPHER_DecryptAEAD(ByVal 0&, 0, lpInput(0), n1, lpKey(0), n2, lpIV(0), n3, lpAAD(0), n4, nOptions)
    If nb <= 0 Then GoTo CleanUp
    ReDim abMyData(nb - 1)
    nb = CIPHER_DecryptAEAD(abMyData(0), nb, lpInput(0), n1, lpKey(0), n2, lpIV(0), n3, lpAAD(0), n4, nOptions)
    If nb <= 0 Then GoTo CleanUp
    ReDim Preserve abMyData(nb - 1)
    cipherDecryptAEAD = abMyData
CleanUp:
    If n4 = 0 Then lpAAD = vbNullString
End Function

'/**
' Decrypts data in a byte array using the specified block cipher algorithm, mode and padding.
' The key and initialization vector are passed as byte arrays.
' @param  lpInput  Input data to be decrypted.
' @param  lpKey    Key of exact length for block cipher algorithm.
' @param  lpIV     Initialization Vector (IV) of exactly the block size (if not provided in input) or empty array for ECB mode.
' @param  szAlgModePad     String with block cipher algorithm, mode and padding,
' e.g. <code>"aes128/cbc/pkcs5"</code>
' {@code
' Alg:  aes128|aes192|aes256|tdea|3des|desede3
' Mode: ecb|cbc|ofb|cfb|ctr
' Pad:  pkcs5|nopad|oneandzeroes|ansix923|w3c
' }
' @param  nOptions  Add `PKI_IV_PREFIX` to expect the IV to be prepended at the start of the input
' (ignored for ECB mode).
' @return Decrypted plaintext in byte array or empty array on error.
' @remark Default padding is `Pkcs5` for ECB and CBC mode and `NoPad` for all other modes.
'**/
Public Function cipherDecryptBytes(lpInput() As Byte, lpKey() As Byte, lpIV() As Byte, szAlgModePad As String, Optional nOptions As Long = 0) As Byte()
    cipherDecryptBytes = vbNullString
    Dim n1 As Long
    n1 = cnvBytesLen(lpInput)
    If n1 = 0 Then Exit Function
    Dim n2 As Long
    n2 = cnvBytesLen(lpKey)
    If n2 = 0 Then Exit Function
    Dim n3 As Long
    n3 = cnvBytesLen(lpIV)
    ' Fudge to allow an empty input array
    If n3 = 0 Then ReDim lpIV(0)
    Dim abMyData() As Byte
    Dim nb As Long
    nb = CIPHER_DecryptBytes(ByVal 0&, 0, lpInput(0), n1, lpKey(0), n2, lpIV(0), n3, szAlgModePad, nOptions)
    If nb <= 0 Then GoTo CleanUp
    ReDim abMyData(nb - 1)
    nb = CIPHER_DecryptBytes(abMyData(0), nb, lpInput(0), n1, lpKey(0), n2, lpIV(0), n3, szAlgModePad, nOptions)
    If nb <= 0 Then GoTo CleanUp
    ReDim Preserve abMyData(nb - 1)
    cipherDecryptBytes = abMyData
CleanUp:
    If n3 = 0 Then lpIV = vbNullString
End Function

' @deprecated Use cipherDecryptBytes()
Public Function cipherDecryptBytes2(lpInput() As Byte, lpKey() As Byte, lpIV() As Byte, szAlgModePad As String, Optional nOptions As Long = 0) As Byte()
    cipherDecryptBytes2 = cipherDecryptBytes(lpInput, lpKey, lpIV, szAlgModePad, nOptions)
End Function

'/**
' Decrypt hex-encoded data using the specified block cipher algorithm, mode and padding.
' The input data, key and initialization vector are all represented as hexadecimal strings.
' @param  szInputHex  Hex-encoded input data.
' @param  szKeyHex    Hex-encoded key of exact key length.
' @param  szIvHex     Hex-encoded IV of exact block length, ignored for ECB mode or if `PKI_IV_PREFIX` is used (use `""`).
' @param  szAlgModePad  String with block cipher algorithm, mode and padding,
' e.g. `"aes128/cbc/pkcs5"`
' {@code
' Alg:  aes128|aes192|aes256|tdea|3des|desede3
' Mode: ecb|cbc|ofb|cfb|ctr
' Pad:  pkcs5|nopad|oneandzeroes|ansix923|w3c
' }
' @param  nOptions  Add `PKI_IV_PREFIX` to expect the IV to be prepended before the ciphertext in the input (not applicable for ECB mode).
' @return Decrypted plaintext in hex-encoded string or empty string on error.
' @remark Input data may be any even number of hex characters, but not zero.
' @remark Default padding is `Pkcs5` for ECB and CBC mode and `NoPad` for all other modes.
'**/
Public Function cipherDecryptHex(szInputHex As String, szKeyHex As String, szIvHex As String, szAlgModePad As String, Optional nOptions As Long = 0) As String
    Dim nc As Long
    nc = CIPHER_DecryptHex(vbNullString, 0, szInputHex, szKeyHex, szIvHex, szAlgModePad, nOptions)
    If nc <= 0 Then Exit Function
    cipherDecryptHex = String(nc, " ")
    nc = CIPHER_DecryptHex(cipherDecryptHex, nc, szInputHex, szKeyHex, szIvHex, szAlgModePad, nOptions)
    cipherDecryptHex = Left$(cipherDecryptHex, nc)
End Function

'/**
' Encrypt data using Authenticated Encryption with Associated Data (AEAD).
' @param  lpInput Byte array containing the input data.
' @param  lpKey Key of exact length for algorithm (16, 24 or 32 bytes).
' @param  lpIV Initialization Vector (IV) (aka nonce) exactly 12 bytes long.
' @param  lpAAD Additional authenticated data (optional) - set as null to ignore.
' @param  nOptions Algorithm to be used. Select one from
' {@code
' PKI_AEAD_AES_128_GCM
' PKI_AEAD_AES_192_GCM
' PKI_AEAD_AES_256_GCM
' }
' and optionally add `PKI_IV_PREFIX` to prepend the IV (nonce) before the ciphertext in the output.
' @return Ciphertext with tag appended in a byte array, or empty array on error.
' @remark The output will either be exactly 16 bytes longer than the input, or exactly 28 bytes longer if API_IV_PREFIX is used.
'**/
Public Function cipherEncryptAEAD(lpInput() As Byte, lpKey() As Byte, lpIV() As Byte, lpAAD() As Byte, nOptions As Long) As Byte()
    cipherEncryptAEAD = vbNullString
    Dim n1 As Long
    n1 = cnvBytesLen(lpInput)
    If n1 = 0 Then Exit Function
    Dim n2 As Long
    n2 = cnvBytesLen(lpKey)
    If n2 = 0 Then Exit Function
    Dim n3 As Long
    n3 = cnvBytesLen(lpIV)
    If n3 = 0 Then Exit Function
    Dim n4 As Long
    n4 = cnvBytesLen(lpAAD)
    ' Fudge to allow an empty input array
    If n4 = 0 Then ReDim lpAAD(0)
    Dim abMyData() As Byte
    Dim nb As Long
    nb = CIPHER_EncryptAEAD(ByVal 0&, 0, lpInput(0), n1, lpKey(0), n2, lpIV(0), n3, lpAAD(0), n4, nOptions)
    If nb <= 0 Then GoTo CleanUp
    ReDim abMyData(nb - 1)
    nb = CIPHER_EncryptAEAD(abMyData(0), nb, lpInput(0), n1, lpKey(0), n2, lpIV(0), n3, lpAAD(0), n4, nOptions)
    If nb <= 0 Then GoTo CleanUp
    ReDim Preserve abMyData(nb - 1)
    cipherEncryptAEAD = abMyData
CleanUp:
    If n4 = 0 Then lpAAD = vbNullString
End Function

'/**
' Encrypt data in a byte array using the specified block cipher algorithm, mode and padding.
' The key and initialization vector are passed as byte arrays.
' @param  lpInput  Input data to be encrypted.
' @param  lpKey    Key of exact length for block cipher algorithm.
' @param  lpIV     Initialization Vector (IV) of exactly the block size or empty array for ECB mode.
' @param  szAlgModePad     String with block cipher algorithm, mode and padding,
' e.g. <code>"aes128/cbc/pkcs5"</code>
' {@code
' Alg:  aes128|aes192|aes256|tdea|3des|desede3
' Mode: ecb|cbc|ofb|cfb|ctr
' Pad:  pkcs5|nopad|oneandzeroes|ansix923|w3c
' }
' @param  nOptions  Add `PKI_IV_PREFIX` to prepend the IV before the ciphertext in the output
' (ignored for ECB mode).
' @return Ciphertext in byte array or empty array on error.
' @remark Default padding is `Pkcs5` for ECB and CBC mode and `NoPad` for all other modes.
'**/
Public Function cipherEncryptBytes(lpInput() As Byte, lpKey() As Byte, lpIV() As Byte, szAlgModePad As String, Optional nOptions As Long = 0) As Byte()
    cipherEncryptBytes = vbNullString
    Dim n1 As Long
    n1 = cnvBytesLen(lpInput)
    ' Fudge to allow an empty input array
    If n1 = 0 Then ReDim lpInput(0)
    Dim n2 As Long
    n2 = cnvBytesLen(lpKey)
    If n2 = 0 Then GoTo CleanUp
    Dim n3 As Long
    n3 = cnvBytesLen(lpIV)
    If n3 = 0 Then ReDim lpIV(0)
    Dim abMyData() As Byte
    Dim nb As Long
    nb = CIPHER_EncryptBytes(ByVal 0&, 0, lpInput(0), n1, lpKey(0), n2, lpIV(0), n3, szAlgModePad, nOptions)
    If nb <= 0 Then GoTo CleanUp
    ReDim abMyData(nb - 1)
    nb = CIPHER_EncryptBytes(abMyData(0), nb, lpInput(0), n1, lpKey(0), n2, lpIV(0), n3, szAlgModePad, nOptions)
    If nb <= 0 Then GoTo CleanUp
    ReDim Preserve abMyData(nb - 1)
    cipherEncryptBytes = abMyData
CleanUp:
    If n1 = 0 Then lpInput = vbNullString
    If n3 = 0 Then lpIV = vbNullString
End Function

' @deprecated Use cipherEncryptBytes()
Public Function cipherEncryptBytes2(lpInput() As Byte, lpKey() As Byte, lpIV() As Byte, szAlgModePad As String, Optional nOptions As Long = 0) As Byte()
    cipherEncryptBytes2 = cipherEncryptBytes(lpInput, lpKey, lpIV, szAlgModePad, nOptions)
End Function

'/**
' Encrypt hex-encoded data using the specified block cipher algorithm, mode and padding.
' The key and initialization vector are passed as hex-encoded strings.
' @param  szInputHex  Input data to be encrypted.
' @param  szKeyHex    Hex-encoded key of exact key length.
' @param  szIvHex     Hex-encoded IV of exact block length or `""` for ECB mode.
' @param  szAlgModePad  String with block cipher algorithm, mode and padding,
' e.g. `"aes128/cbc/pkcs5"`
' {@code
' Alg:  aes128|aes192|aes256|tdea|3des|desede3
' Mode: ecb|cbc|ofb|cfb|ctr
' Pad:  pkcs5|nopad|oneandzeroes|ansix923|w3c
' }
' @param  nOptions  Add `PKI_IV_PREFIX` to prepend the IV before the ciphertext in the output
' (ignored for ECB mode).
' @return Encrypted ciphertext in hex-encoded string or empty string on error.
' @remark Input data may be any even number of hex characters, but not zero.
' @remark Default padding is `Pkcs5` for ECB and CBC mode and `NoPad` for all other modes.
'**/
Public Function cipherEncryptHex(szInputHex As String, szKeyHex As String, szIvHex As String, szAlgModePad As String, Optional nOptions As Long = 0) As String
    Dim nc As Long
    nc = CIPHER_EncryptHex(vbNullString, 0, szInputHex, szKeyHex, szIvHex, szAlgModePad, nOptions)
    If nc <= 0 Then Exit Function
    cipherEncryptHex = String(nc, " ")
    nc = CIPHER_EncryptHex(cipherEncryptHex, nc, szInputHex, szKeyHex, szIvHex, szAlgModePad, nOptions)
    cipherEncryptHex = Left$(cipherEncryptHex, nc)
End Function

'/**
' Unwraps (decrypts) key material with a key-encryption key.
' @param  lpData Wrapped key.
' @param  lpKEK Key encryption key.
' @param  nOptions Algorithm to be used. Select one from:
' {@code
' PKI_BC_AES128
' PKI_BC_AES192
' PKI_BC_AES256
' PKI_BC_3DES
' }
' @return Unwrapped key material (or empty array on error).
'**/
Public Function cipherKeyUnwrap(lpData() As Byte, lpKEK() As Byte, nOptions As Long) As Byte()
    cipherKeyUnwrap = vbNullString
    Dim n1 As Long
    n1 = cnvBytesLen(lpData)
    If n1 = 0 Then Exit Function
    Dim n2 As Long
    n2 = cnvBytesLen(lpKEK)
    If n2 = 0 Then Exit Function
    Dim abMyData() As Byte
    Dim nb As Long
    nb = CIPHER_KeyUnwrap(ByVal 0&, 0, lpData(0), n1, lpKEK(0), n2, nOptions)
    If nb <= 0 Then Exit Function
    ReDim abMyData(nb - 1)
    nb = CIPHER_KeyUnwrap(abMyData(0), nb, lpData(0), n1, lpKEK(0), n2, nOptions)
    If nb <= 0 Then Exit Function
    ReDim Preserve abMyData(nb - 1)
    cipherKeyUnwrap = abMyData
End Function

'/**
' Wraps (encrypts) key material with a key-encryption key.
' @param  lpData Key material to be wrapped.
' @param  lpKEK Key encryption key.
' @param  nOptions Algorithm to be used. Select one from:
' {@code
' PKI_BC_AES128
' PKI_BC_AES192
' PKI_BC_AES256
' PKI_BC_3DES
' }
' @return Wrapped key (or empty array on error).
'**/
Public Function cipherKeyWrap(lpData() As Byte, lpKEK() As Byte, nOptions As Long) As Byte()
    cipherKeyWrap = vbNullString
    Dim n1 As Long
    n1 = cnvBytesLen(lpData)
    If n1 = 0 Then Exit Function
    Dim n2 As Long
    n2 = cnvBytesLen(lpKEK)
    If n2 = 0 Then Exit Function
    Dim abMyData() As Byte
    Dim nb As Long
    nb = CIPHER_KeyWrap(ByVal 0&, 0, lpData(0), n1, lpKEK(0), n2, nOptions)
    If nb <= 0 Then Exit Function
    ReDim abMyData(nb - 1)
    nb = CIPHER_KeyWrap(abMyData(0), nb, lpData(0), n1, lpKEK(0), n2, nOptions)
    If nb <= 0 Then Exit Function
    ReDim Preserve abMyData(nb - 1)
    cipherKeyWrap = abMyData
End Function

'/**
' Extract the message digest from a signed-data CMS object file and verify the signature.
' @param  szFileIn Name of signed-data CMS object file or the data as a base64 or PEM string.
' @param  szCertFile An (optional) X.509 certificate file to be used to identify the signer.
' @param  nOptions For future use.
' @return Hash value in hex format or an empty string on error.
' @remark If no certificate is given, it will use the first valid SignerInfo and certificate pair it finds in the SignedData.
' @remark RSASSA-PKCS1V1_5 only.
'**/
Public Function cmsGetSigDataDigest(szFileIn As String, Optional szCertFile As String = "", Optional nOptions As Long = 0) As String
    ' CMS_GetSigDataDigest does not return the output length, plus it appends a NUL character to the end
    Dim n As Long
    cmsGetSigDataDigest = String(PKI_MAX_HASH_CHARS, " ")
    n = CMS_GetSigDataDigest(cmsGetSigDataDigest, Len(cmsGetSigDataDigest), szFileIn, szCertFile, nOptions)
    If n < 0 Then Exit Function
    cmsGetSigDataDigest = Trim(cmsGetSigDataDigest)
    cmsGetSigDataDigest = Replace(cmsGetSigDataDigest, Chr(0), "")
End Function

'/**
' Create a CMS enveloped-data object for one or more recipients.
' @param  szFileOut Name of output file to be created.
' @param  szFileIn Name of file containing input data.
' @param  szCertList List of one or more recipient X.509 certificate filenames, separated by semicolons (;).
' A certificate's representation in base64 or as a PEM string may be used instead of a filename.
' Alternatively, specify a single PKCS#7 certificate chain file (.p7c/.p7b).
' <br><em>Special cases:</em> Set as `"type=@pwri"` to create a single recipientInfo of the `PasswordRecipientInfo` (pwri) type;
' or set as `"type=@kekri,keyid=&lt;string&gt;"` to create a single recipientInfo of the `KEKRecipientInfo` (kekri) type. See Remarks.
' @param szKeyString (formerly szSeed) Use to pass optional additional user key material (ukm) for KDF where KeyAgreement (kari) type is used.
' Or use to pass the password for a pwri type or the key encryption key (KEK) for a kekri type.
' Either pass a plain ASCII string, e.g. "abc" or use the format `"#x&lt;hex-digits&gt;"` to pass a string of arbitrary octet values,
' e.g. `"#xdeadbeef01"` to pass the 5 bytes `0xde,0xad,0xbe,0xef,0x01`. Required for pwri and kekri types.
' @param  nOptions Select the content encryption algorithm from:
' {@code
' PKI_BC_3DES (default)
' PKI_BC_AES128
' PKI_BC_AES192
' PKI_BC_AES256
' PKI_AEAD_AES_128_GCM
' PKI_AEAD_AES_192_GCM
' PKI_AEAD_AES_256_GCM
' }
' To set the key transport scheme (where applicable), use one of
' {@code
' PKI_KT_RSAES_PKCS (default)
' PKI_KT_RSAES_OAEP
' }
' If you have selected `PKI_KT_RSAES_OAEP` then, optionally, add
' {@code
' PKI_MGF_MGF1SHA1
' }
' Select one hash algorithm for RSAES-OAEP or ECDH KDF or pwri PBKDF2:
' {@code
' PKI_HASH_SHA1 (default)
' PKI_HASH_SHA224
' PKI_HASH_SHA256
' PKI_HASH_SHA384
' PKI_HASH_SHA512
' }
' To set the key derivation function (KDF) for the ECDH key agreement scheme (where applicable), add one of:
' {@code
' PKI_KDF_X963 (default)
' PKI_KDF_HKDF
' }
' add one key wrap algorithm for the ECDH key agreement scheme or the kekri key encryption algorithm (default=match content encryption algorithm):
' {@code
' PKI_KWRAP_3DES (allowed only if Triple DES is used for content encryption)
' PKI_KWRAP_AES128
' PKI_KWRAP_AES192
' PKI_KWRAP_AES256
' }
' Optionally, add any of the bitflags:
' {@code
' PKI_CMS_FORMAT_BASE64 (default=binary)
' PKI_CMS_ALT_ALGID
' PKI_CMS_BIGFILE (binary file to binary file only)
' }
' @param nCount Use to pass the iteration count for a pwri type (default=4096) or tag length for AuthEnvelopedData (in range 12-16, default=16). Otherwise ignored.
' @return Number of successful recipients or a negative error code.
' @remark The `recipientInfo` type for each recipient is set automatically depending on the public key found in their certificate.
' If RSA, the key transport technique (ktri) will be used.
' If ECC, then the standard ECDH ephemeral-static key agreement technique (kari) will be used.
' @example
' {@code
' ' Create an enveloped CMS object (ktri type) to Bob using Bob's RSA key...
' n = cmsMakeEnvData("cms2bob_aes128.p7m", "excontent.txt", "BobRSASignByCarl.cer", "", PKI_BC_AES128 Or PKI_KT_RSAES_OAEP)
' ' Same but using authenticated encryption and creating an authEnvelopedData object...
' n = cmsMakeEnvData("cms2bob_aes128auth.p7m", "excontent.txt", "BobRSASignByCarl.cer", "", PKI_AEAD_AES_128_GCM Or PKI_KT_RSAES_OAEP)
' ' Create an enveloped CMS object (kari type) to Dana using Dana's ECC key...
' n = cmsMakeEnvData("cms2dana_hkdf.p7m", "excontent.txt", "lamps-dana.encrypt.crt", "", PKI_BC_AES256 Or PKI_HASH_SHA256 Or PKI_KDF_HKDF Or PKI_KWRAP_AES256)
' ' Create an enveloped CMS object (kekri type) using a previously distributed symmetric key-encryption key (KEK)...
' n = cmsMakeEnvData("cms_envdata_kekri.p7m", "excontent.txt", "type=@kekri,keyid=ourcommonkey", "#x0123456789ABCDEFF0E1D2C3B4A59687", PKI_BC_AES256 Or PKI_HASH_SHA256 Or PKI_KWRAP_AES128)
' ' Create an enveloped CMS object (pwri type) using password-based key management...
' n = cmsMakeEnvData("cms_envdata_pwri.p7m", "excontent.txt", "type=@pwri", "password12345", PKI_BC_AES192)
' }
'**/
Public Function cmsMakeEnvData(szFileOut As String, szFileIn As String, szCertList As String, Optional szKeyString As String = "", Optional nOptions As Long = 0, Optional nCount As Long = 0) As Long
    cmsMakeEnvData = CMS_MakeEnvData(szFileOut, szFileIn, szCertList, szKeyString, nCount, nOptions)
End Function

'/**
' Create a CMS enveloped-data object from data in a byte array.
' @param  szFileOut Name of output file to be created.
' @param  lpInput Input data.
' @param  szCertList List of one or more recipient X.509 certificate filenames, separated by semicolons (;).
' A certificate's representation in base64 or as a PEM string may be used instead of a filename.
' Alternatively, specify a single PKCS#7 certificate chain file (.p7c/.p7b).
' <br><em>Special cases:</em> Set as `"type=@pwri"` to create a single recipientInfo of the `PasswordRecipientInfo` (pwri) type;
' or set as `"type=@kekri,keyid=&lt;string&gt;"` to create a single recipientInfo of the `KEKRecipientInfo` (kekri) type. See Remarks.
' @param szKeyString (formerly szSeed) Use to pass optional additional user key material (ukm) for KDF where KeyAgreement (kari) type is used.
' Or use to pass the password for a pwri type or the key encryption key (KEK) for a kekri type.
' Either pass a plain ASCII string, e.g. "abc" or use the format `"#x&lt;hex-digits&gt;"` to pass a string of arbitrary octet values,
' e.g. `"#xdeadbeef01"` to pass the 5 bytes `0xde,0xad,0xbe,0xef,0x01`. Required for pwri and kekri types.
' @param nOptions See the options in {@link cmsMakeEnvData}.
' @param nCount Use to pass the iteration count for a pwri type (default=4096) or tag length for AuthEnvelopedData (in range 12-16, default=16). Otherwise ignored.
' @return Number of successful recipients or a negative error code.
' @remark See remarks in {@link cmsMakeEnvData}
'**/
Public Function cmsMakeEnvDataFromBytes(szFileOut As String, lpInput() As Byte, szCertList As String, Optional szKeyString As String = "", Optional nOptions As Long = 0, Optional nCount As Long = 0) As Long
    Dim n1 As Long
    n1 = cnvBytesLen(lpInput)
    If n1 = 0 Then  ' Fudge
        ReDim lpInput(0)
    End If
    cmsMakeEnvDataFromBytes = CMS_MakeEnvDataFromBytes(szFileOut, lpInput(0), n1, szCertList, szKeyString, nCount, nOptions)
    If n1 = 0 Then lpInput = vbNullString
End Function

'/**
' Create a CMS enveloped-data object from an ASCII string.
' @param  szFileOut Name of output file to be created.
' @param  szInput Input data.
' @param  szCertList List of one or more recipient X.509 certificate filenames, separated by semicolons (;).
' A certificate's representation in base64 or as a PEM string may be used instead of a filename.
' Alternatively, specify a single PKCS#7 certificate chain file (.p7c/.p7b).
' <br><em>Special cases:</em> Set as `"type=@pwri"` to create a single recipientInfo of the `PasswordRecipientInfo` (pwri) type;
' or set as `"type=@kekri,keyid=&lt;string&gt;"` to create a single recipientInfo of the `KEKRecipientInfo` (kekri) type. See Remarks.
' @param szKeyString (formerly szSeed) Use to pass optional additional user key material (ukm) for KDF where KeyAgreement (kari) type is used.
' Or use to pass the password for a pwri type or the key encryption key (KEK) for a kekri type.
' Either pass a plain ASCII string, e.g. "abc" or use the format `"#x&lt;hex-digits&gt;"` to pass a string of arbitrary octet values,
' e.g. `"#xdeadbeef01"` to pass the 5 bytes `0xde,0xad,0xbe,0xef,0x01`. Required for pwri and kekri types.
' @param nOptions See the options in {@link cmsMakeEnvData}.
' @param nCount Use to pass the iteration count for a pwri type (default=4096) or tag length for AuthEnvelopedData (in range 12-16, default=16). Otherwise ignored.
' @return Number of successful recipients or a negative error code.
' @remark See remarks in {@link cmsMakeEnvData}
'**/
Public Function cmsMakeEnvDataFromString(szFileOut As String, szInput As String, szCertList As String, Optional szKeyString As String = "", Optional nOptions As Long = 0, Optional nCount As Long = 0) As Long
    cmsMakeEnvDataFromString = CMS_MakeEnvDataFromString(szFileOut, szInput, szCertList, szKeyString, nCount, nOptions)
End Function

'/**
' Create a CMS signed-data object from data in a byte array.
' @param  szFileOut Name of output file to be created.
' @param  lpInput Input data.
' @param  szCertList Filename of the signer's certificate (or a string with its base64 or PEM representation)
' and (optionally) a list of other certificates to be included in the output, separated by semi-colons (;)
' Alternatively, specify a single PKCS#7 certificate chain file (.p7c/.p7b) containing the signer's certificate.
' @param szPrivateKey Internal representation of private key for the sender.
' @param  nOptions Select the signature algorithm from one of:
' {@code
' PKI_SIG_RSA_SHA1
' PKI_SIG_RSA_SHA224
' PKI_SIG_RSA_SHA256
' PKI_SIG_RSA_SHA384
' PKI_SIG_RSA_SHA512
' PKI_SIG_RSA_MD5
' PKI_SIG_RSA_PSS_SHA1
' PKI_SIG_RSA_PSS_SHA224
' PKI_SIG_RSA_PSS_SHA256
' PKI_SIG_RSA_PSS_SHA384
' PKI_SIG_RSA_PSS_SHA512
' PKI_SIG_ECDSA_SHA1
' PKI_SIG_ECDSA_SHA224
' PKI_SIG_ECDSA_SHA256
' PKI_SIG_ECDSA_SHA384
' PKI_SIG_ECDSA_SHA512
' PKI_SIG_ED25519
' }
' and optionally add any of the following:
' {@code
' PKI_CMS_EXCLUDE_CERTS
' PKI_CMS_EXCLUDE_DATA
' PKI_CMS_CERTS_ONLY
' PKI_CMS_INCLUDE_ATTRS
' PKI_CMS_FORMAT_BASE64
' PKI_CMS_NO_OUTER
' PKI_CMS_ALT_ALGID
' PKI_CMS_BIGFILE
' PKI_PSS_SALTLEN_ZERO
' PKI_MGF_MGF1SHA1
' }
' If the `PKI_CMS_INCLUDE_ATTRS` option flag is included, optionally add any of the following:
' {@code
' PKI_CMS_ADD_SIGNTIME
' PKI_CMS_ADD_SMIMECAP
' PKI_CMS_ADD_SIGNINGCERT
' PKI_CMS_ADD_ALGPROTECT
' }
' @return Zero if successful or a nonzero error code.
'**/
Public Function cmsMakeSigDataFromBytes(szFileOut As String, lpInput() As Byte, szCertList As String, szPrivateKey As String, Optional nOptions As Long = 0) As Long
    Dim n1 As Long
    n1 = cnvBytesLen(lpInput)
    If n1 = 0 Then  ' Fudge
        ReDim lpInput(0)
    End If
    cmsMakeSigDataFromBytes = CMS_MakeSigDataFromBytes(szFileOut, lpInput(0), n1, szCertList, szPrivateKey, nOptions)
    If n1 = 0 Then lpInput = vbNullString
End Function

'/**
' Query a CMS enveloped-data object file for selected information.
' @param  szFileIn Name of file containing CMS enveloped-data object (binary or base64-encoded) or the data as a base64 or PEM string.
' @param  szQuery Query string (case insensitive). Valid queries are:
' {@code
' "version"
' "recipientInfoVersion"
' "recipientInfoType"
' "CountOfRecipientInfos"
' "recipientIssuerName"
' "recipientSerialNumber"
' "keyEncryptionAlgorithm"
' "keyEncryptionFlags"
' "SizeofEncryptedKey"
' "encryptedKey"
' "oaepParams"
' "keyWrapAlgorithm"
' "originatorKeyAlgorithm"
' "originatorPublicKey"
' "keyid"
' "contentEncryptionAlgorithm"
' "SizeofEncryptedContent"
' "encryptedContent"
' "iv"
' }
' @param  nOptions For future use.
' @return String containing the result or an empty string if not found or error.
' @remark By default, the function queries the first recipientInfo in the file. To query the nth recipientInfo append "/n" to the query string,
' e.g. `"recipientInfoVersion/2"` to find the version number of the second recipientInfo in the file.
'**/
Public Function cmsQueryEnvData(szFileIn As String, szQuery As String, Optional nOptions As Long = 0) As String
    Dim n As Long
    n = CMS_QueryEnvData("", 0, "", szQuery, PKI_QUERY_GETTYPE)
    If PKI_QUERY_NUMBER = n Then
        ' Output is a number, but here we return it as a string, e.g. "256"
        n = CMS_QueryEnvData("", 0, szFileIn, szQuery, nOptions)
        If n <= 0 Then Exit Function
        cmsQueryEnvData = CStr(n)
    ElseIf PKI_QUERY_STRING = n Then
        ' Output is a string
        Dim nc As Long
        nc = CMS_QueryEnvData(vbNullString, 0, szFileIn, szQuery, nOptions)
        If nc <= 0 Then Exit Function
        cmsQueryEnvData = String(nc, " ")
        nc = CMS_QueryEnvData(cmsQueryEnvData, nc, szFileIn, szQuery, nOptions)
        cmsQueryEnvData = Left$(cmsQueryEnvData, nc)
    End If
End Function

'/**
' Query a CMS signed-data object file for selected information.
' @param  szFileIn Name of file containing CMS signed-data object (binary or base64-encoded) or the data as a base64 or PEM string.
' @param  szQuery Query string (case insensitive). Valid queries are:
' {@code
' "version"
' "eContentType"
' "HASeContent"
' "CountOfCertificates"
' "CountOfSignerInfos"
' "signerInfoVersion"
' "digestAlgorithm"
' "signatureAlgorithm"
' "HASsignedAttributes"
' "signingTime"
' "messageDigest"
' "pssParams"
' "HASsigningCertificate"
' "HASalgorithmProtection"
' }
' @param  nOptions For future use.
' @return String containing the result or an empty string if not found or error.
' @remark By default, the function queries the first signerInfo in the file. To query the nth signerInfo append "/n" to the query string,
' e.g. `"signerInfoVersion/2"` to find the version number of the second signerInfo in the file.
'**/
Public Function cmsQuerySigData(szFileIn As String, szQuery As String, Optional nOptions As Long = 0) As String
    Dim n As Long
    n = CMS_QuerySigData("", 0, "", szQuery, PKI_QUERY_GETTYPE)
    If PKI_QUERY_NUMBER = n Then
        ' Output is a number, but here we return it as a string, e.g. "256"
        n = CMS_QuerySigData("", 0, szFileIn, szQuery, nOptions)
        If n <= 0 Then Exit Function
        cmsQuerySigData = CStr(n)
    ElseIf PKI_QUERY_STRING = n Then
        ' Output is a string
        Dim nc As Long
        nc = CMS_QuerySigData(vbNullString, 0, szFileIn, szQuery, nOptions)
        If nc <= 0 Then Exit Function
        cmsQuerySigData = String(nc, " ")
        nc = CMS_QuerySigData(cmsQuerySigData, nc, szFileIn, szQuery, nOptions)
        cmsQuerySigData = Left$(cmsQuerySigData, nc)
    End If
End Function

'/**
' Read and decrypt a CMS enveloped-data object to a byte array.
' @param  szFileIn Name of file containing CMS enveloped-data object (binary or base64-encoded) or the data as a base64 or PEM string.
' @param  szCertFile Filename of the recipient's X.509 certificate (optional).
' @param  szPrivateKey Internal representation of private key.
' @param  nOptions For future use.
' @return Decrypted content in a byte array, or empty array on error.
' @remark Use this if the content contains non-ASCII characters, e.g. UTF-8 encoded.
'**/
Public Function cmsReadEnvDataToBytes(szFileIn As String, szCertFile As String, szPrivateKey As String, Optional nOptions As Long = 0) As Byte()
    cmsReadEnvDataToBytes = vbNullString
    Dim abMyData() As Byte
    Dim nb As Long
    nb = CMS_ReadEnvDataToBytes(ByVal 0&, 0, szFileIn, szCertFile, szPrivateKey, nOptions)
    If nb <= 0 Then Exit Function
    ReDim abMyData(nb - 1)
    nb = CMS_ReadEnvDataToBytes(abMyData(0), nb, szFileIn, szCertFile, szPrivateKey, nOptions)
    If nb <= 0 Then Exit Function
    ReDim Preserve abMyData(nb - 1)
    cmsReadEnvDataToBytes = abMyData
End Function

'/**
' Read and decrypt a CMS enveloped-data object to a string.
' @param  szFileIn Name of file containing CMS enveloped-data object (binary or base64-encoded) or the data as a base64 or PEM string.
' @param  szCertFile Filename of the recipient's X.509 certificate (optional).
' @param  szPrivateKey Internal representation of private key.
' @param  nOptions For future use.
' @return Decrypted content in a string or empty string on error.
' @remark Use this only when the decrypted text is known to be plain ASCII text, otherwise use `cmsReadEnvDataToBytes()`.
'**/
Public Function cmsReadEnvDataToString(szFileIn As String, szCertFile As String, szPrivateKey As String, Optional nOptions As Long = 0) As String
    Dim nc As Long
    nc = CMS_ReadEnvDataToString(vbNullString, 0, szFileIn, szCertFile, szPrivateKey, nOptions)
    If nc <= 0 Then Exit Function
    cmsReadEnvDataToString = String(nc, " ")
    nc = CMS_ReadEnvDataToString(cmsReadEnvDataToString, nc, szFileIn, szCertFile, szPrivateKey, nOptions)
    cmsReadEnvDataToString = Left$(cmsReadEnvDataToString, nc)
End Function

'/**
' Read the content from a CMS signed-data object directly into a byte array.
' @param  szFileIn Name of file containing CMS signed-data object (binary or base64-encoded) or the data as a base64 or PEM string.
' @param  nOptions For future use.
' @return Byte array containing the content or a zero-length array if error.
' @remark Use this if the content contains non-ASCII characters, e.g. UTF-8 encoded.
'**/
Public Function cmsReadSigDataToBytes(szFileIn As String, Optional nOptions As Long = 0) As Byte()
    cmsReadSigDataToBytes = vbNullString
    Dim abMyData() As Byte
    Dim nb As Long
    nb = CMS_ReadSigDataToBytes(ByVal 0&, 0, szFileIn, nOptions)
    If nb <= 0 Then Exit Function
    ReDim abMyData(nb - 1)
    nb = CMS_ReadSigDataToBytes(abMyData(0), nb, szFileIn, nOptions)
    If nb <= 0 Then Exit Function
    ReDim Preserve abMyData(nb - 1)
    cmsReadSigDataToBytes = abMyData
End Function

'/**
' Read the content from a CMS signed-data object directly into a string.
' @param  szFileIn Name of file containing CMS signed-data object (binary or base64-encoded) or the data as a base64 or PEM string.
' @param  nOptions For future use.
' @return String containing the content or an empty string on error.
' @remark Use this only if the content is known to be plain ASCII text, otherwise use `cmsReadSigDataToBytes()`.
'**/
Public Function cmsReadSigDataToString(szFileIn As String, Optional nOptions As Long = 0) As String
    Dim nc As Long
    nc = CMS_ReadSigDataToString(vbNullString, 0, szFileIn, nOptions)
    If nc <= 0 Then Exit Function
    cmsReadSigDataToString = String(nc, " ")
    nc = CMS_ReadSigDataToString(cmsReadSigDataToString, nc, szFileIn, nOptions)
    cmsReadSigDataToString = Left$(cmsReadSigDataToString, nc)
End Function

'/**
' Convert 8-bit binary data to equivalent base58-encoded string format.
' @param  lpInput Binary data.
' @return Base58-encoded string.
' @remark This uses the "Bitcoin" scheme of base58 encoding where the leading character "1"
' is reserved for representing an entire leading zero byte.
'**/
Public Function cnvBase58FromBytes(lpInput() As Byte) As String
    Dim n1 As Long
    n1 = cnvBytesLen(lpInput)
    If n1 = 0 Then Exit Function
    Dim nc As Long
    nc = CNV_Base58FromBytes(vbNullString, 0, lpInput(0), n1)
    If nc <= 0 Then Exit Function
    cnvBase58FromBytes = String(nc, " ")
    nc = CNV_Base58FromBytes(cnvBase58FromBytes, nc, lpInput(0), n1)
    cnvBase58FromBytes = Left$(cnvBase58FromBytes, nc)
End Function

'/**
' Convert a base58-encoded string to an equivalent array of 8-bit unsigned integers.
' @param  szInput Base58-encoded data.
' @return Data as array of bytes.
' @remark This uses the "Bitcoin" scheme of base58 encoding where the leading character "1"
' is reserved for representing an entire leading zero byte.
'**/
Public Function cnvBase58ToBytes(szInput As String) As Byte()
    cnvBase58ToBytes = vbNullString
    Dim abMyData() As Byte
    Dim nb As Long
    nb = CNV_Base58ToBytes(ByVal 0&, 0, szInput)
    If nb <= 0 Then Exit Function
    ReDim abMyData(nb - 1)
    nb = CNV_Base58ToBytes(abMyData(0), nb, szInput)
    If nb <= 0 Then Exit Function
    ReDim Preserve abMyData(nb - 1)
    cnvBase58ToBytes = abMyData
End Function

'/**
' Convert encoding of byte array between UTF-8 and Latin-1.
' @param  lpInput Base58-encoded data.
' @param nOptions Option flags. Select one of:
' {@code
' PKI_CNV_UTF8_FROM_LATIN1
' PKI_CNV_LATIN1_FROM_UTF8
' }
' @return Converted data (or empty array on error).
'**/
Public Function cnvByteEncoding(lpInput() As Byte, nOptions As Long) As Byte()
    cnvByteEncoding = vbNullString
    Dim n1 As Long
    n1 = cnvBytesLen(lpInput)
    If n1 = 0 Then Exit Function
    Dim abMyData() As Byte
    Dim nb As Long
    nb = CNV_ByteEncoding(ByVal 0&, 0, lpInput(0), n1, nOptions)
    If nb <= 0 Then Exit Function
    ReDim abMyData(nb - 1)
    nb = CNV_ByteEncoding(abMyData(0), nb, lpInput(0), n1, nOptions)
    If nb <= 0 Then Exit Function
    ReDim Preserve abMyData(nb - 1)
    cnvByteEncoding = abMyData
End Function

'/**
' Check if a byte array contains valid UTF-8 characters.
' @param  lpInput data to be checked
' @return Zero if the data is invalid UTF-8, or a positive number (1-3) if the input contains valid UTF-8 data.
' @remark The return value indicates the nature of the encoded characters:
' {@code
' 0 = Not valid UTF-8
' 1 = Valid UTF-8, all chars are 7-bit ASCII
' 2 = Valid UTF-8, contains at least one multi-byte character equivalent to 8-bit ANSI
' 3 = Valid UTF-8, contains at least one multi-byte character that cannot be represented in a single-byte character set
' }
'**/
Public Function cnvCheckUTF8Bytes(lpInput() As Byte) As Long
    cnvCheckUTF8Bytes = CNV_CheckUTF8Bytes(lpInput(0), cnvBytesLen(lpInput))
End Function

'/**
' Convert UTF-8 encoded array of bytes into a Latin-1 string, if possible.
' @param  lpInput Array containing UTF-8 encoded data.
' @return Decoded bytes in a VBA Unicode string.
'**/
Public Function cnvLatin1FromUTF8Bytes(lpInput() As Byte) As String
    Dim n1 As Long
    n1 = cnvBytesLen(lpInput)
    If n1 = 0 Then Exit Function
    Dim nc As Long
    nc = CNV_Latin1FromUTF8Bytes(vbNullString, 0, lpInput(0), n1)
    If nc <= 0 Then Exit Function
    cnvLatin1FromUTF8Bytes = String(nc, " ")
    nc = CNV_Latin1FromUTF8Bytes(cnvLatin1FromUTF8Bytes, nc, lpInput(0), n1)
    cnvLatin1FromUTF8Bytes = Left$(cnvLatin1FromUTF8Bytes, nc)
End Function

'/**
' Convert the leftmost four bytes of an array to a 32-bit integer.
' @param lpInput Byte array to be converted.
' @param nOptions Option flags. Use 0 for default big-endian order or one of:
' {@code
' PKI_CNV_BIG_ENDIAN (0)
' PKI_CNV_LITTLE_ENDIAN
' }
' @return Decoded integer value.
' @remark An array shorter than 4 bytes will be padded on the right with zeros.
' @example
' {@code
' Debug.Print Hex(cnvNumFromBytes(cnvFromHex("DEADBEEF")))
' 'DEADBEEF
' Debug.Print cnvNumFromBytes(cnvFromHex("DEADBEEF"))
' '-559038737
' }
'**/
Public Function cnvNumFromBytes(lpInput() As Byte, Optional nOptions As Long = 0) As Long
    Dim nb As Long
    nb = cnvBytesLen(lpInput)
    If nb = 0 Then Exit Function
    cnvNumFromBytes = CNV_NumFromBytes(lpInput(0), nb, nOptions)
End Function

'/**
' Convert a 32-bit integer to an array of 4 bytes.
' @param  nNumber Integer to be converted.
' @param nOptions Option flags. Use 0 for default big-endian order or one of:
' {@code
' PKI_CNV_BIG_ENDIAN (0)
' PKI_CNV_LITTLE_ENDIAN
' }
' @return Byte array containing representation of integer in given order.
' @example
' {@code
' Debug.Print cnvToHex(cnvNumToBytes(&HDEADBEEF, PKI_CNV_LITTLE_ENDIAN))
' 'EFBEADDE
' }
'**/
Public Function cnvNumToBytes(nNumber As Long, Optional nOptions As Long = 0) As Byte()
    Dim abMyData() As Byte
    Dim nb As Long
    Dim r As Long
    cnvNumToBytes = vbNullString
    nb = 4
    ReDim abMyData(nb - 1)
    r = CNV_NumToBytes(abMyData(0), nb, nNumber, nOptions)
    If r < 0 Then Exit Function
    cnvNumToBytes = abMyData
End Function

'/**
' Convert a string of 8-bit Latin-1 characters into a UTF-8 encoded array of bytes.
' @param  szInput String of Latin-1 characters to be converted.
' @return UTF-8 encoded sequence of bytes.
'**/
Public Function cnvUTF8BytesFromLatin1(szInput As String) As Byte()
    cnvUTF8BytesFromLatin1 = vbNullString
    Dim abMyData() As Byte
    Dim nb As Long
    nb = CNV_UTF8BytesFromLatin1(ByVal 0&, 0, szInput)
    If nb <= 0 Then Exit Function
    ReDim abMyData(nb - 1)
    nb = CNV_UTF8BytesFromLatin1(abMyData(0), nb, szInput)
    If nb <= 0 Then Exit Function
    ReDim Preserve abMyData(nb - 1)
    cnvUTF8BytesFromLatin1 = abMyData
End Function

'/**
' Compress data using zlib compression.
' @param  lpInput Data to be compressed.
' @param  nOptions For future use.
' @return Compressed data, or an empty array on error.
'**/
Public Function comprCompress(lpInput() As Byte, Optional nOptions As Long = 0) As Byte()
    comprCompress = vbNullString
    Dim n1 As Long
    n1 = cnvBytesLen(lpInput)
    If n1 = 0 Then Exit Function
    Dim abMyData() As Byte
    Dim nb As Long
    nb = COMPR_Compress(ByVal 0&, 0, lpInput(0), n1, nOptions)
    If nb <= 0 Then Exit Function
    ReDim abMyData(nb - 1)
    nb = COMPR_Compress(abMyData(0), nb, lpInput(0), n1, nOptions)
    If nb <= 0 Then Exit Function
    ReDim Preserve abMyData(nb - 1)
    comprCompress = abMyData
End Function

'/**
' Uncompress data using zlib compression.
' @param  lpInput Data to be uncompressed.
' @param  nOptions For future use.
' @return Uncompressed data, or an empty array on error.
'**/
Public Function comprUncompress(lpInput() As Byte, Optional nOptions As Long = 0) As Byte()
    comprUncompress = vbNullString
    Dim n1 As Long
    n1 = cnvBytesLen(lpInput)
    If n1 = 0 Then Exit Function
    Dim abMyData() As Byte
    Dim nb As Long
    nb = COMPR_Uncompress(ByVal 0&, 0, lpInput(0), n1, nOptions)
    If nb <= 0 Then Exit Function
    ReDim abMyData(nb - 1)
    nb = COMPR_Uncompress(abMyData(0), nb, lpInput(0), n1, nOptions)
    If nb <= 0 Then Exit Function
    ReDim Preserve abMyData(nb - 1)
    comprUncompress = abMyData
End Function

'/**
' Compute EC Diffie-Hellman (ECDH) shared secret.
' @param  szIntPrivateKey String containing our own private key in ephemeral "internal" form.
' @param  szIntPublicKey String containing other party's public key in "internal" form.
' @param  nOptions For future use.
' @return The Diffie-Hellman shared secret, or an empty array on error.
'**/
Public Function eccDHSharedSecret(szIntPrivateKey As String, szIntPublicKey As String, Optional nOptions As Long = 0) As Byte()
    Dim abMyData() As Byte
    Dim nb As Long
    eccDHSharedSecret = vbNullString
    nb = ECC_DHSharedSecret(ByVal 0&, 0, szIntPrivateKey, szIntPublicKey, nOptions)
    If nb <= 0 Then Exit Function
    ReDim abMyData(nb - 1)
    nb = ECC_DHSharedSecret(abMyData(0), nb, szIntPrivateKey, szIntPublicKey, nOptions)
    If nb <= 0 Then Exit Function
    ReDim Preserve abMyData(nb - 1)
    eccDHSharedSecret = abMyData
End Function

'/**
' Convert an internal EC private key string into an internal EC public key string.
' @param  szIntKeyString Private key in ephemeral "internal" representation.
' @param  nOptions For future use.
' @return Public key in ephemeral "internal" representation, or empty string on error.
'**/
Public Function eccPublicKeyFromPrivate(szIntKeyString As String, Optional nOptions As Long = 0) As String
    Dim nc As Long
    nc = ECC_PublicKeyFromPrivate(vbNullString, 0, szIntKeyString, nOptions)
    If nc <= 0 Then Exit Function
    eccPublicKeyFromPrivate = String(nc, " ")
    nc = ECC_PublicKeyFromPrivate(eccPublicKeyFromPrivate, nc, szIntKeyString, nOptions)
    eccPublicKeyFromPrivate = Left$(eccPublicKeyFromPrivate, nc)
End Function

'/**
' Query an EC key string for selected information.
' @param  szIntKeyString Key in ephemeral "internal" representation.
' @param  szQuery  Query string (case insensitive). Valid queries are:
' {@code
' curveName
' keyBits
' isPrivate
' privateKey
' publicKey
' }
' @param  nOptions For future use.
' @return String containing the result or an empty string if not found or error.
'**/
Public Function eccQueryKey(szIntKeyString As String, szQuery As String, Optional nOptions As Long = 0) As String
    Dim n As Long
    n = ECC_QueryKey("", 0, "", szQuery, PKI_QUERY_GETTYPE)
    If PKI_QUERY_NUMBER = n Then
        ' Output is a number, but here we return it as a string, e.g. "256"
        n = ECC_QueryKey("", 0, szIntKeyString, szQuery, nOptions)
        If n < 0 Then Exit Function    ' [2021-10-23 Fixed "<=0"->"<0"]
        eccQueryKey = CStr(n)
    ElseIf PKI_QUERY_STRING = n Then
        ' Output is a string
        Dim nc As Long
        nc = ECC_QueryKey(vbNullString, 0, szIntKeyString, szQuery, nOptions)
        If nc <= 0 Then Exit Function
        eccQueryKey = String(nc, " ")
        nc = ECC_QueryKey(eccQueryKey, nc, szIntKeyString, szQuery, nOptions)
        eccQueryKey = Left$(eccQueryKey, nc)
    End If
End Function

' /**
' Generate an EC public/private key pair and save as two key files.
' @param szPubKeyFile Output filename for public key.
' @param szPriKeyFile Output filename for (encrypted) private key.
' @param szCurveName Name of elliptic curve
' @param szPassword Password for encrypted private key (required).
' @param szParams Optional parameters. A set of attribute name=value pairs separated by a semicolon ";" (see remarks).
' @param  nOptions Use 0 for defaults.
' <br>
' A flag to indicate the password-based encryption scheme to be used to encrypt the private key file. Select from:
' {@code
' PKI_PBE_SHA_3DES (0) for "pbeWithSHAAnd3-KeyTripleDES-CBC" from PKCS12 (default)
' PKI_PBE_PBKDF2_DESEDE3 for PBKDF2 using des-EDE3-CBC
' PKI_PBE_PBKDF2_AES128 for PBKDF2 using aes128-CBC
' PKI_PBE_PBKDF2_AES192 for PBKDF2 using aes192-CBC
' PKI_PBE_PBKDF2_AES256 for PBKDF2 using aes256-CBC
' }
' plus optionally to output in textual PEM format [default format=DER binary]
' {@code
' PKI_KEY_FORMAT_PEM
' }
' @return Zero if successful.
' @remark Valid name-value pair parameters for `szParams` are:<br>
' __count__=integer | To set the iteration count used in the PBKDF2 method, e.g. `"count=5000;"` [default=2048].<br>
' __prf__=hmac-name | To change the HMAC algorithm used in the PBKDF2 method, e.g. `"prf=hmacWithSHA256;"` [default=`hmacWithSHA1`].<br>
' __rngseed__=string | To add some user-supplied entropy for the key generation process, e.g. `"rngseed=pqrrr1234xyz;"`.<br>
' Valid values for hmac-name are `{hmacWithSHA1,hmacWithSHA224,hmacWithSHA256,hmacWithSHA384,hmacWithSHA512}`.
' @example
' {@code
' ' Create an ECC key pair using defaults
' r = eccMakeKeys("myeccP256.pub", "myeccP256.p8e", "Secp256r1", "password")
' ' Same but using different curve, stronger security and in PEM format
' r = eccMakeKeys("myeccBP256r1.pub", "myeccBP256r1.p8e", "brainpoolP256r1", "password1", "count=6000;prf=hmacWithSHA256", PKI_PBE_PBKDF2_AES128 Or PKI_KEY_FORMAT_PEM)
' }
'**/
Public Function eccMakeKeys(szPubKeyFile As String, szPriKeyFile As String, szCurveName As String, szPassword As String, Optional szParams As String = "", Optional nOptions As Long = 0) As Long
    eccMakeKeys = ECC_MakeKeys(szPubKeyFile, szPriKeyFile, szCurveName, szPassword, szParams, nOptions)
End Function


'/**
' Read an EC key from its hexadecimal representation.
' @param  szHexKey Hexadecimal representation of the key, private or public.
' @param  szCurveName Name of the elliptic curve.
' @param  nOptions For __Safe Curves__ specify `PKI_ECC_PRIVATE_KEY` or `PKI_ECC_PUBLIC_KEY` to indicate that the key value
' represents a private or public key, respectively. Otherwise, `nOptions` is ignored.
' @return The key in ephemeral "internal" representation, or empty string on error.
'**/
Public Function eccReadKeyByCurve(szHexKey As String, szCurveName As String, Optional nOptions As Long = 0) As String
    Dim nc As Long
    nc = ECC_ReadKeyByCurve(vbNullString, 0, szHexKey, szCurveName, nOptions)
    If nc <= 0 Then Exit Function
    eccReadKeyByCurve = String(nc, " ")
    nc = ECC_ReadKeyByCurve(eccReadKeyByCurve, nc, szHexKey, szCurveName, nOptions)
    eccReadKeyByCurve = Left$(eccReadKeyByCurve, nc)
End Function

'/**
' Read an EC private key from a file into an internal key string.
' @param  szKeyFileOrString Either the name of file containing the key or a string containing the key in PEM format.
' @param  szPassword Password for the key file, if encrypted; otherwise set as `""`.
' @param  nOptions For future use.
' @return String containing an internal representation of the private key, or empty string on error.
'**/
Public Function eccReadPrivateKey(szKeyFileOrString As String, szPassword As String, Optional nOptions As Long = 0) As String
    Dim nc As Long
    nc = ECC_ReadPrivateKey(vbNullString, 0, szKeyFileOrString, szPassword, nOptions)
    If nc <= 0 Then Exit Function
    eccReadPrivateKey = String(nc, " ")
    nc = ECC_ReadPrivateKey(eccReadPrivateKey, nc, szKeyFileOrString, szPassword, nOptions)
    eccReadPrivateKey = Left$(eccReadPrivateKey, nc)
End Function

'/**
' Read an EC private key from a file into an internal key string.
' @param  szKeyFileOrString Either the name of file containing the key or a string containing the key in PEM format.
' @param  nOptions For future use.
' @return String containing an internal representation of the public key, or empty string on error.
'**/
Public Function eccReadPublicKey(szKeyFileOrString As String, Optional nOptions As Long = 0) As String
    Dim nc As Long
    nc = ECC_ReadPublicKey(vbNullString, 0, szKeyFileOrString, nOptions)
    If nc <= 0 Then Exit Function
    eccReadPublicKey = String(nc, " ")
    nc = ECC_ReadPublicKey(eccReadPublicKey, nc, szKeyFileOrString, nOptions)
    eccReadPublicKey = Left$(eccReadPublicKey, nc)
End Function

'/**
' Compute the hash code of an "internal" ECC public or private key string.
' @param  szIntKeyString Key in ephemeral "internal" representation.
' @return A 32-bit hash code for the key, or zero on error.
' @remark Should be the same for a matching private and public key.
'**/
Public Function eccKeyHashCode(szIntKeyString As String) As Long
    eccKeyHashCode = ECC_KeyHashCode(szIntKeyString)
End Function

'/**
' Compute hash digest in byte format of byte input.
' @param  lpMessage Message to be digested in byte array.
' @param  nOptions  Algorithm to be used. Select one from:
' {@code
' PKI_HASH_SHA1
' PKI_HASH_SHA224
' PKI_HASH_SHA256
' PKI_HASH_SHA384
' PKI_HASH_SHA512
' PKI_HASH_MD5
' PKI_HASH_MD2
' PKI_HASH_RMD160
' PKI_HASH_BTC160
' }
' and optionally add `PKI_HASH_DOUBLE` to compute a double hash, `HASH(HASH(m))`.
' @return Message digest in byte array.
'**/
Public Function hashBytes(lpMessage() As Byte, nOptions As Long) As Byte()
    hashBytes = vbNullString
    Dim n1 As Long
    n1 = cnvBytesLen(lpMessage)
    ' Fudge to allow an empty input array
    If n1 = 0 Then ReDim lpMessage(0)
    Dim abMyData() As Byte
    Dim nb As Long
    nb = HASH_Bytes(ByVal 0&, 0, lpMessage(0), n1, nOptions)
    If nb <= 0 Then GoTo CleanUp
    ReDim abMyData(nb - 1)
    nb = HASH_Bytes(abMyData(0), nb, lpMessage(0), n1, nOptions)
    If nb <= 0 Then GoTo CleanUp
    ReDim Preserve abMyData(nb - 1)
    hashBytes = abMyData
CleanUp:
    If n1 = 0 Then lpMessage = vbNullString
End Function

'/**
' Compute hash digest in byte format of a file.
' @param  szFileName Name of file containing message data.
' @param  nOptions  Algorithm to be used. Select one from:
' {@code
' PKI_HASH_SHA1
' PKI_HASH_SHA224
' PKI_HASH_SHA256
' PKI_HASH_SHA384
' PKI_HASH_SHA512
' PKI_HASH_MD5
' PKI_HASH_MD2
' PKI_HASH_RMD160
' PKI_HASH_BTC160
' }
' and optionally add `PKI_HASH_DOUBLE` to compute a double hash, `HASH(HASH(m))`.
' Add `PKI_HASH_MODE_TEXT` to hash in "text" mode instead of default "binary" mode.
' @return Message digest in byte array.
' @remark The default mode is "binary" where each byte is treated individually.
' In "text" mode CR-LF pairs will be treated as a single newline (LF) character.
'**/
Public Function hashFile(szFileName As String, nOptions As Long) As Byte()
    hashFile = vbNullString
    Dim abMyData() As Byte
    Dim nb As Long
    nb = HASH_File(ByVal 0&, 0, szFileName, nOptions)
    If nb <= 0 Then Exit Function
    ReDim abMyData(nb - 1)
    nb = HASH_File(abMyData(0), nb, szFileName, nOptions)
    If nb <= 0 Then Exit Function
    ReDim Preserve abMyData(nb - 1)
    hashFile = abMyData
End Function

'/**
' Compute hash digest in hex format of byte input.
' @param  lpMessage Message to be digested in byte array.
' @param  nOptions  Algorithm to be used. Select one from:
' {@code
' PKI_HASH_SHA1
' PKI_HASH_SHA224
' PKI_HASH_SHA256
' PKI_HASH_SHA384
' PKI_HASH_SHA512
' PKI_HASH_MD5
' PKI_HASH_MD2
' PKI_HASH_RMD160
' PKI_HASH_BTC160
' }
' and optionally add `PKI_HASH_DOUBLE` to compute a double hash, `HASH(HASH(m))`.
' @return Message digest in hex-encoded format.
'**/
Public Function hashHexFromBytes(lpMessage() As Byte, nOptions As Long) As String
    Dim n1 As Long
    n1 = cnvBytesLen(lpMessage)
    ' Fudge to allow empty input array
    If n1 = 0 Then ReDim lpMessage(0)
    Dim nc As Long
    nc = HASH_HexFromBytes(vbNullString, 0, lpMessage(0), n1, nOptions)
    If nc <= 0 Then GoTo CleanUp
    hashHexFromBytes = String(nc, " ")
    nc = HASH_HexFromBytes(hashHexFromBytes, nc, lpMessage(0), n1, nOptions)
    hashHexFromBytes = Left$(hashHexFromBytes, nc)
CleanUp:
    If n1 = 0 Then lpMessage = vbNullString
End Function

'/**
' Compute hash digest in hex format of a file.
' @param  szFileName Name of file containing message data.
' @param  nOptions  Algorithm to be used. Select one from:
' {@code
' PKI_HASH_SHA1
' PKI_HASH_SHA224
' PKI_HASH_SHA256
' PKI_HASH_SHA384
' PKI_HASH_SHA512
' PKI_HASH_MD5
' PKI_HASH_MD2
' PKI_HASH_RMD160
' PKI_HASH_BTC160
' }
' and optionally add `PKI_HASH_DOUBLE` to compute a double hash, `HASH(HASH(m))`.
' Add `PKI_HASH_MODE_TEXT` to hash in "text" mode instead of default "binary" mode.
' @return Message digest in hex-encoded format.
' @remark The default mode is "binary" where each byte is treated individually.
' In "text" mode CR-LF pairs will be treated as a single newline (LF) character.
'**/
Public Function hashHexFromFile(szFileName As String, nOptions As Long) As String
    Dim nc As Long
    nc = HASH_HexFromFile(vbNullString, 0, szFileName, nOptions)
    If nc <= 0 Then Exit Function
    hashHexFromFile = String(nc, " ")
    nc = HASH_HexFromFile(hashHexFromFile, nc, szFileName, nOptions)
    hashHexFromFile = Left$(hashHexFromFile, nc)
End Function

'/**
' Compute hash digest in hex-encoded format from hex-encoded input.
' @param  szMsgHex Message to be digested in hex-encoded format.
' @param  nOptions  Algorithm to be used. Select one from:
' {@code
' PKI_HASH_SHA1
' PKI_HASH_SHA224
' PKI_HASH_SHA256
' PKI_HASH_SHA384
' PKI_HASH_SHA512
' PKI_HASH_MD5
' PKI_HASH_MD2
' PKI_HASH_RMD160
' PKI_HASH_BTC160
' }
' and optionally add `PKI_HASH_DOUBLE` to compute a double hash, `HASH(HASH(m))`.
' @return Message digest in hex-encoded format.
'**/
Public Function hashHexFromHex(szMsgHex As String, nOptions As Long) As String
    Dim nc As Long
    nc = HASH_HexFromHex(vbNullString, 0, szMsgHex, nOptions)
    If nc <= 0 Then Exit Function
    hashHexFromHex = String(nc, " ")
    nc = HASH_HexFromHex(hashHexFromHex, nc, szMsgHex, nOptions)
    hashHexFromHex = Left$(hashHexFromHex, nc)
End Function

'/**
' Return length of message digest output in bytes.
' @param  nAlgId  Algorithm Id flag. Select one of `PKI_HASH_*` or `PKI_HMAC_*`, for example:
' {@code
' PKI_HASH_SHA1
' PKI_HASH_SHA224
' PKI_HASH_SHA256
' PKI_HASH_SHA384
' PKI_HASH_SHA512
' PKI_HASH_MD5
' PKI_HASH_MD2
' PKI_HASH_RMD160
' PKI_HASH_BTC160
' }
' @return Length of the hash function output in bytes; else a negative error code.
' @example
' {@code
' Debug.Print hashLength(PKI_HASH_SHA512)
' 64
' }
'**/
Public Function hashLength(nAlgId As Long) As Long
    hashLength = HASH_Length(nAlgId)
End Function

'/**
' Compute hash-based message authentication code (HMAC) as a byte array from byte data.
' @param  lpMessage Message to be signed in byte format.
' @param  lpKey     Key in byte format.
' @param  nOptions  Algorithm to be used. Select one from:
' {@code
' PKI_HMAC_SHA1
' PKI_HMAC_SHA224
' PKI_HMAC_SHA256
' PKI_HMAC_SHA384
' PKI_HMAC_SHA512
' PKI_HMAC_MD5
' }
' @return HMAC value in byte array.
'**/
Public Function hmacBytes(lpMessage() As Byte, lpKey() As Byte, nOptions As Long) As Byte()
    hmacBytes = vbNullString
    Dim n1 As Long
    n1 = cnvBytesLen(lpMessage)
    ' Fudge to allow an empty input array
    If n1 = 0 Then ReDim lpMessage(0)
    Dim n2 As Long
    n2 = cnvBytesLen(lpKey)
    If n2 = 0 Then GoTo CleanUp
    Dim abMyData() As Byte
    Dim nb As Long
    nb = HMAC_Bytes(ByVal 0&, 0, lpMessage(0), n1, lpKey(0), n2, nOptions)
    If nb <= 0 Then GoTo CleanUp
    ReDim abMyData(nb - 1)
    nb = HMAC_Bytes(abMyData(0), nb, lpMessage(0), n1, lpKey(0), n2, nOptions)
    If nb <= 0 Then GoTo CleanUp
    ReDim Preserve abMyData(nb - 1)
    hmacBytes = abMyData
CleanUp:
    If n1 = 0 Then lpMessage = vbNullString
End Function

'/**
' Compute hash-based message authentication code (HMAC) in hexadecimal format from byte data.
' @param  lpMessage Message to be signed in byte format.
' @param  lpKey     Key in byte format.
' @param  nOptions  Algorithm to be used. Select one from:
' {@code
' PKI_HMAC_SHA1
' PKI_HMAC_SHA224
' PKI_HMAC_SHA256
' PKI_HMAC_SHA384
' PKI_HMAC_SHA512
' PKI_HMAC_MD5
' }
' @return HMAC value in hex-encoded format.
'**/
Public Function hmacHexFromBytes(lpMessage() As Byte, lpKey() As Byte, nOptions As Long) As String
    Dim n1 As Long
    n1 = cnvBytesLen(lpMessage)
    ' Fudge to allow empty input array
    If n1 = 0 Then ReDim lpMessage(0)
    Dim n2 As Long
    n2 = cnvBytesLen(lpKey)
    If n2 = 0 Then GoTo CleanUp
    Dim nc As Long
    nc = HMAC_HexFromBytes(vbNullString, 0, lpMessage(0), n1, lpKey(0), n2, nOptions)
    If nc <= 0 Then GoTo CleanUp
    hmacHexFromBytes = String(nc, " ")
    nc = HMAC_HexFromBytes(hmacHexFromBytes, nc, lpMessage(0), n1, lpKey(0), n2, nOptions)
    hmacHexFromBytes = Left$(hmacHexFromBytes, nc)
CleanUp:
    If n1 = 0 Then lpMessage = vbNullString
End Function

'/**
' Compute hash-based message authentication code (HMAC) in hexadecimal format from data in hexadecimal-encoded strings.
' @param  szMsgHex Message to be signed in hex-encoded format.
' @param  szKeyHex Key in hex-encoded format.
' @param  nOptions  Algorithm to be used. Select one from:
' {@code
' PKI_HMAC_SHA1
' PKI_HMAC_SHA224
' PKI_HMAC_SHA256
' PKI_HMAC_SHA384
' PKI_HMAC_SHA512
' PKI_HMAC_MD5
' }
' @return HMAC value in hex-encoded format.
'**/
Public Function hmacHexFromHex(szMsgHex As String, szKeyHex As String, nOptions As Long) As String
    Dim nc As Long
    nc = HMAC_HexFromHex(vbNullString, 0, szMsgHex, szKeyHex, nOptions)
    If nc <= 0 Then Exit Function
    hmacHexFromHex = String(nc, " ")
    nc = HMAC_HexFromHex(hmacHexFromHex, nc, szMsgHex, szKeyHex, nOptions)
    hmacHexFromHex = Left$(hmacHexFromHex, nc)
End Function

'/**
' Generate a key-encryption key (KEK) from input keying material (IKM) using a key derivation function (KDF).
' @param  nKekBytes Required length of output key material in bytes.
' @param  lpIKM Input key material/shared secret.
' @param  lpInfo SharedInfo (optional, but a properly dimensioned variable must be passed, even if empty).
' @param  nOptions  Algorithm to be used. Select one from:
' {@code
' PKI_KDF_X963 (default)
' PKI_KDF_HKDF
' }
' and select one hash algorithm to use with the key derivation function:
' {@code
' PKI_HASH_SHA1 (default)
' PKI_HASH_SHA224
' PKI_HASH_SHA256
' PKI_HASH_SHA384
' PKI_HASH_SHA512
' }
' @param  szParams Optional parameters. Set as `""` for defaults.
' Use `salt=&lt;hex-digits&gt;` to set the optional salt parameter for the HKDF algorithm encoded in hex,
' e.g. `"salt=606162636465666768696a6b6c6d6e6f;"`.
' @return Output key material (KEK) in a byte array.
' @remarks `PKI_KDF_X963` uses the ANSI-X9.63-KDF key derivation function.
' `PKI_KDF_HKDF` uses the HMAC-based Key Derivation Function (HKDF) from RFC 5869.
' @example
' {@code
' Dim lpKEK() As Byte
' Dim lpZZ() As Byte
' Dim lpInfo() As Byte
' ' ansx963_2001.rsp CAVS 12.0 'ANS X9.63-2001' information for sample
' lpZZ = cnvFromHex("96c05619d56c328ab95fe84b18264b08725b85e33fd34f08")
' lpKEK = kdfBytes(128 \ 8, lpZZ, lpInfo, PKI_HASH_SHA256)
' Debug.Print "KEK = " & cnvToHex(lpKEK)
' Debug.Print "OK  = 443024c3dae66b95e6f5670601558f71"
' ' [RFC 5869] A.1.  Test Case 1 Basic test case with SHA-256
' lpZZ = cnvFromHex("0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b")
' lpInfo = cnvFromHex("f0f1f2f3f4f5f6f7f8f9")
' lpKEK = kdfBytes(42, lpZZ, lpInfo, PKI_KDF_HKDF Or PKI_HASH_SHA256, "salt=000102030405060708090a0b0c")
' Debug.Print "KEK = " & cnvToHex(lpKEK)
' Debug.Print "OK  = 3cb25f25faacd57a90434f64d0362f2a2d2d0a90cf1a5a4c5db02d56ecc4c5bf34007208d5b887185865"
' }
'**/
Public Function kdfBytes(nKekBytes As Long, lpIKM() As Byte, lpInfo() As Byte, Optional nOptions As Long = 0, Optional szParams As String = "") As Byte()
    kdfBytes = vbNullString
    If nKekBytes <= 0 Then Exit Function
    Dim n1 As Long
    n1 = cnvBytesLen(lpIKM)
    If n1 = 0 Then Exit Function
    Dim n2 As Long
    n2 = cnvBytesLen(lpInfo)    ' Can be zero
    If n2 = 0 Then ReDim lpInfo(0)
    Dim abMyData() As Byte
    ReDim abMyData(nKekBytes - 1)
    Dim r As Long
    r = KDF_Bytes(abMyData(0), nKekBytes, lpIKM(0), n1, lpInfo(0), n2, szParams, nOptions)
    ' Returns 0 on success
    If r <> 0 Then GoTo CleanUp
    kdfBytes = abMyData
CleanUp:
    If n2 = 0 Then lpInfo = vbNullString
End Function

'/**
' Generate a key-encryption key (KEK) for ECDH key exchange in a CMS EnvelopedData object.
' @param  nKekBytes Required length of output key material in bytes.
' @param  lpZZ Input key material/shared secret.
' @param  lpUkm User key material (optional, but a properly dimensioned variable must be passed, even if empty).
' @param  nOptions  Algorithm to be used. Select one from:
' {@code
' PKI_KDF_X963 (default)
' PKI_KDF_HKDF
' }
' and select one hash algorithm to use with the key derivation function:
' {@code
' PKI_HASH_SHA1 (default)
' PKI_HASH_SHA224
' PKI_HASH_SHA256
' PKI_HASH_SHA384
' PKI_HASH_SHA512
' }
' and select one key wrap algorithm (required, no default):
' {@code
' PKI_KWRAP_3DES
' PKI_KWRAP_AES128
' PKI_KWRAP_AES192
' PKI_KWRAP_AES256
' }
' @return Output key material (KEK) in a byte array.
' @remarks This is a specialist function using the key definition algorithms described in [RFC5753] and [RFC8418]
' when used for key agreement with ECDH in a CMS EnvelopedData object using the ECC-CMS-SharedInfo structure.
' @example
' {@code
' Dim lpKEK() As Byte
' Dim lpZZ() As Byte
' Dim lpUkm() As Byte
' lpZZ = cnvFromHex("160E3F5588C6FB4E9CEE8BC3C1C5000AB86396468C3D1CAEC0CB6E21536B5513")
' lpKEK = kdfForCms(lpZZ, lpUkm, PKI_KWRAP_AES128 Or PKI_KDF_X963 Or PKI_HASH_SHA1)
' Debug.Print "KEK = " & cnvToHex(lpKEK)
' Debug.Print "OK  = 04D616C654CDF62BB186A5A088B60FB5"
' }
'**/
Public Function kdfForCms(lpZZ() As Byte, lpUkm() As Byte, Optional nOptions As Long = 0) As Byte()
    kdfForCms = vbNullString
    Dim n1 As Long
    n1 = cnvBytesLen(lpZZ)
    If n1 = 0 Then Exit Function
    Dim n2 As Long
    n2 = cnvBytesLen(lpUkm)    ' Can be zero
    If n2 = 0 Then ReDim lpUkm(0)
    Dim abMyData() As Byte
    Dim nb As Long
    nb = KDF_ForCms(ByVal 0&, 0, lpZZ(0), n1, lpUkm(0), n2, "", nOptions)
    If nb <= 0 Then GoTo CleanUp
    ReDim abMyData(nb - 1)
    nb = KDF_ForCms(abMyData(0), nb, lpZZ(0), n1, lpUkm(0), n2, "", nOptions)
    If nb <= 0 Then GoTo CleanUp
    kdfForCms = abMyData
CleanUp:
    If n2 = 0 Then lpUkm = vbNullString
End Function

'/**
' Create an Online Certification Status Protocol (OCSP) request as a base64 string.
' @param  szIssuerCert Name of issuer's X.509 certificate file (or string with its base64 representation).
' @param  szCertFileOrSerialNum Either the name of X.509 certificate file to be checked or its serial number in hexadecimal format preceded by `#x`.
' @param  nOptions  Algorithm to be used. Select one from:
' {@code
' PKI_HASH_SHA1
' PKI_HASH_SHA224
' PKI_HASH_SHA256
' PKI_HASH_SHA384
' PKI_HASH_SHA512
' PKI_HASH_MD5
' }
' @param  szExtensions For future use.
' @return A base64 string suitable for an OCSP request to an Online Certificate Status Manager or an empty string on error.
' @remark Note different order of parameters from core function.
'**/
Public Function ocspMakeRequest(szIssuerCert As String, szCertFileOrSerialNum As String, nOptions As Long, Optional szExtensions As String = "") As String
    ' NOTE changed order of parameters!
    Dim nc As Long
    nc = OCSP_MakeRequest(vbNullString, 0, szIssuerCert, szCertFileOrSerialNum, szExtensions, nOptions)
    If nc <= 0 Then Exit Function
    ocspMakeRequest = String(nc, " ")
    nc = OCSP_MakeRequest(ocspMakeRequest, nc, szIssuerCert, szCertFileOrSerialNum, szExtensions, nOptions)
    ocspMakeRequest = Left$(ocspMakeRequest, nc)
End Function

'/**
' Read a response to an Online Certification Status Protocol (OCSP) request and outputs the main results in text form.
' @param  szResponseFile Name of the file containing the response data in BER format.
' @param  szIssuerCert (optional) Name of issuer's X.509 certificate file (or string with its base64 representation).
' @param  nOptions  For future use.
' @param  szExtensions For future use.
' @return A text string outlining the main results in the response data or an empty string on error.
' @remark Note different order of parameters from core function.
'**/
Public Function ocspReadResponse(szResponseFile As String, Optional szIssuerCert As String = "", Optional nOptions As Long = 0, Optional szExtensions As String = "") As String
    ' NOTE changed order of parameters!
    Dim nc As Long
    nc = OCSP_ReadResponse(vbNullString, 0, szResponseFile, szIssuerCert, szExtensions, nOptions)
    If nc <= 0 Then Exit Function
    ocspReadResponse = String(nc, " ")
    nc = OCSP_ReadResponse(ocspReadResponse, nc, szResponseFile, szIssuerCert, szExtensions, nOptions)
    ocspReadResponse = Left$(ocspReadResponse, nc)
End Function

'/**
' Creates an input block suitably padded for encryption by a block cipher in ECB or CBC mode.
' @param  lpInput Plaintext bytes to be padded.
' @param  nBlkLen Cipher block length in bytes (8 or 16).
' @param  nOptions Use 0 for default PKCS5 padding or select one of:
' {@code
' PKI_PAD_1ZERO
' PKI_PAD_AX923
' PKI_PAD_W3C
' }
' @return Padded data in byte array.
'**/
Public Function padBytesBlock(lpInput() As Byte, nBlkLen As Long, Optional nOptions As Long = 0) As Byte()
    padBytesBlock = vbNullString
    Dim n1 As Long
    n1 = cnvBytesLen(lpInput)
    If n1 = 0 Then Exit Function
    Dim abMyData() As Byte
    Dim nb As Long
    nb = PAD_BytesBlock(ByVal 0&, 0, lpInput(0), n1, nBlkLen, nOptions)
    If nb <= 0 Then Exit Function
    ReDim abMyData(nb - 1)
    nb = PAD_BytesBlock(abMyData(0), nb, lpInput(0), n1, nBlkLen, nOptions)
    If nb <= 0 Then Exit Function
    ReDim Preserve abMyData(nb - 1)
    padBytesBlock = abMyData
End Function

'/**
' Creates a hex-encoded input block suitably padded for encryption by a block cipher in ECB or CBC mode.
' @param  szInput Hexadecimal-encoded data to be padded.
' @param  nBlkLen Cipher block length in bytes (8 or 16).
' @param  nOptions Use 0 for default PKCS5 padding or select one of:
' {@code
' PKI_PAD_1ZERO
' PKI_PAD_AX923
' PKI_PAD_W3C
' }
' @return Padded data in hex-encoded string.
'**/
Public Function padHexBlock(szInput As String, nBlkLen As Long, Optional nOptions As Long = 0) As String
    Dim nc As Long
    nc = PAD_HexBlock(vbNullString, 0, szInput & "", nBlkLen, nOptions)
    If nc <= 0 Then Exit Function
    padHexBlock = String(nc, " ")
    nc = PAD_HexBlock(padHexBlock, nc, szInput & "", nBlkLen, nOptions)
    padHexBlock = Left$(padHexBlock, nc)
End Function

'/**
' Removes the padding from an encryption block.
' @param  lpInput Padded data.
' @param  nBlkLen Cipher block length in bytes (8 or 16).
' @param  nOptions Use 0 for default PKCS5 padding or select one of:
' {@code
' PKI_PAD_1ZERO
' PKI_PAD_AX923
' PKI_PAD_W3C
' }
' @return Unpadded data in byte array or _unchanged_ data on error.
' @remark An error is indicated by returning the _original_ data which will always be longer than the expected unpadded result.
'**/
Public Function padUnpadBytes(lpInput() As Byte, nBlkLen As Long, Optional nOptions As Long = 0) As Byte()
    Dim lpOutput() As Byte
    Dim nb As Long
    padUnpadBytes = vbNullString
    ' No need to query for length because we know the output will be shorter than input
    ' so make sure output is as long as the input
    nb = cnvBytesLen(lpInput)
    If nb = 0 Then Exit Function
    ReDim lpOutput(nb - 1)
    nb = PAD_UnpadBytes(lpOutput(0), nb, lpInput(0), nb, nBlkLen, nOptions)
    If nb <= 0 Then Exit Function
    ' Re-dimension the output to the correct length
    ReDim Preserve lpOutput(nb - 1)
    padUnpadBytes = lpOutput
End Function

'/**
' Removes the padding from a hex-encoded encryption block.
' @param  szInput Hex-encoded padded data.
' @param  nBlkLen Cipher block length in bytes (8 or 16).
' @param  nOptions Use 0 for default PKCS5 padding or select one of:
' {@code
' PKI_PAD_1ZERO
' PKI_PAD_AX923
' PKI_PAD_W3C
' }
' @return Unpadded data in hex-encoded string or _unchanged_ data on error.
' @remark An error is indicated by returning the _original_ data which will always be longer than the expected unpadded result.
'**/
Public Function padUnpadHex(szInput As String, nBlkLen As Long, Optional nOptions As Long = 0) As String
    Dim nc As Long
    ' No need to query for length because we know the output will be shorter than input
    nc = Len(szInput)
    padUnpadHex = String(nc, " ")
    nc = PAD_UnpadHex(padUnpadHex, nc, szInput, nBlkLen, nOptions)
    If nc < 0 Then
        ' Return original input on error - user to catch
        padUnpadHex = szInput
        Exit Function
    End If
    padUnpadHex = Left$(padUnpadHex, nc)
End Function

'/**
' Derives a key of any length from a password using the PBKDF2 algorithm from PKCS#5 v2.1.
' @param  dkBytes Required length of key in bytes.
' @param  lpPwd Password encoded as byte array.
' @param  lpSalt Salt in a byte array.
' @param  nCount Iteration count.
' @param  nOptions  Hash algorithm to use in HMAC PRF. Select one from:
' {@code
' PKI_HMAC_SHA1
' PKI_HMAC_SHA224
' PKI_HMAC_SHA256
' PKI_HMAC_SHA384
' PKI_HMAC_SHA512
' PKI_HMAC_MD5
' }
' @return Key in byte array.
'**/
Public Function pbeKdf2(dkBytes As Long, lpPwd() As Byte, lpSalt() As Byte, nCount As Long, Optional nOptions As Long = 0) As Byte()
    pbeKdf2 = vbNullString
    Dim n1 As Long
    n1 = cnvBytesLen(lpPwd)
    If n1 = 0 Then Exit Function
    Dim n2 As Long
    n2 = cnvBytesLen(lpSalt)
    If n2 = 0 Then Exit Function
    Dim abMyData() As Byte
    ReDim abMyData(dkBytes - 1)
    Dim r As Long
    r = PBE_Kdf2(abMyData(0), dkBytes, lpPwd(0), n1, lpSalt(0), n2, nCount, nOptions)
    If r < 0 Then Exit Function
    pbeKdf2 = abMyData
End Function

'/**
' Derives a hex-encoded key of any length from a password using the PBKDF2 algorithm from PKCS#5 v2.1. The salt and derived key are encoded in hexadecimal.
' @param  dkBytes Required length of key in bytes.
' @param  szPwd Password (as normal text).
' @param  szSaltHex Salt in hex-encoded format.
' @param  nCount Iteration count.
' @param  nOptions  Hash algorithm to use in HMAC PRF. Select one from:
' {@code
' PKI_HMAC_SHA1
' PKI_HMAC_SHA224
' PKI_HMAC_SHA256
' PKI_HMAC_SHA384
' PKI_HMAC_SHA512
' PKI_HMAC_MD5
' }
' @return Key in hex format.
'**/
Public Function pbeKdf2Hex(dkBytes As Long, szPwd As String, szSaltHex As String, nCount As Long, Optional nOptions As Long = 0) As String
    Dim r As Long
    pbeKdf2Hex = String(dkBytes * 2, " ")
    r = PBE_Kdf2Hex(pbeKdf2Hex, Len(pbeKdf2Hex), dkBytes, szPwd, szSaltHex, nCount, nOptions)
    If r < 0 Then Exit Function
End Function

'/**
' Get version number of native core DLL.
' @return Version number as an integer in form `Major*100*100 + Minor*100 + Revision`. For example, version 6.1.2 would return `60102`.
'**/
Public Function pkiVersion() As Long
    pkiVersion = PKI_Version(0, 0)
End Function

'/**
' Returns the ASCII value of the licence type.
' @param  nOptions For future use.
' @return `D`=Developer `T`=Trial.
'**/
Public Function pkiLicenceType(Optional nOptions As Long = 0) As String
    Dim n As Long
    n = PKI_LicenceType(nOptions)
    pkiLicenceType = Chr(n)
End Function

'/**
' Get date and time the CryptoSys PKI DLL module was last compiled.
' @return Date and time string.
'**/
Public Function pkiCompileTime() As String
    Dim nc As Long
    nc = PKI_CompileTime(vbNullString, 0)
    If nc <= 0 Then Exit Function
    pkiCompileTime = String(nc, " ")
    nc = PKI_CompileTime(pkiCompileTime, nc)
    pkiCompileTime = Left$(pkiCompileTime, nc)
End Function

'/**
' Get last error message set by previous function.
' @return Final error message from last call (may be empty).
'**/
Public Function pkiLastError() As String
    Dim nc As Long
    nc = PKI_LastError(vbNullString, 0)
    If nc <= 0 Then Exit Function
    pkiLastError = String(nc, " ")
    nc = PKI_LastError(pkiLastError, nc)
    pkiLastError = Left$(pkiLastError, nc)
End Function

'/**
' Returns the error code of the error that occurred when calling the last function.
' @return Error code (see {@link pkiErrorLookup}).
' @remark Not all functions set this value.
'**/
Public Function pkiErrorCode() As Long
    pkiErrorCode = PKI_ErrorCode()
End Function

'/**
' Get additional information about the core DLL module.
' @param  nOptions For future use.
' @return Additional information, e.g. "Licensed Developer Edition".
'**/
Public Function pkiModuleInfo(Optional nOptions As Long = 0) As String
    Dim nc As Long
    nc = PKI_ModuleInfo(vbNullString, 0, nOptions)
    If nc <= 0 Then Exit Function
    pkiModuleInfo = String(nc, " ")
    nc = PKI_ModuleInfo(pkiModuleInfo, nc, nOptions)
    pkiModuleInfo = Left$(pkiModuleInfo, nc)
End Function

'/**
' Get path name of the current process's module.
' @param  nOptions For future use.
' @return File path to current DLL module.
' @example
' {@code
' Debug.Print pkiModuleName()
' C:\WINDOWS\SYSTEM32\diCrPKI.dll
' }
'**/
Public Function pkiModuleName(Optional nOptions As Long = 0) As String
    Dim nc As Long
    nc = PKI_ModuleName(vbNullString, 0, nOptions)
    If nc <= 0 Then Exit Function
    pkiModuleName = String(nc, " ")
    nc = PKI_ModuleName(pkiModuleName, nc, nOptions)
    pkiModuleName = Left$(pkiModuleName, nc)
End Function

'/**
' Get platform the core DLL was compiled for.
' @return `"Win32"` or `"X64"`.
'**/
Public Function pkiPlatform() As String
    Dim nc As Long
    nc = PKI_Platform(vbNullString, 0)
    If nc <= 0 Then Exit Function
    pkiPlatform = String(nc, " ")
    nc = PKI_Platform(pkiPlatform, nc)
    pkiPlatform = Left$(pkiPlatform, nc)
End Function

'/**
' Generate random bytes.
' @param  nBytes Required number of random bytes.
' @return Array of random bytes.
'**/
Public Function rngBytes(nBytes As Long) As Byte()
    rngBytes = vbNullString
    Dim abMyData() As Byte
    ReDim abMyData(nBytes - 1)
    Call RNG_Bytes(abMyData(0), nBytes, 0, 0)
    rngBytes = abMyData
End Function

'/**
' Generate a random 36-character Global Unique IDentifier (GUID) string.
' @return String of the form "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx" where "x" is a hexadecimal digit [0-9a-f].
' @example
' {@code
' Debug.Print rngGuid()
' ba849198-168e-4632-a865-2761c9c8dd37
' }
'**/
Public Function rngGuid() As String
    rngGuid = String(PKI_RNG_GUID_CHARS, " ")
    Call RNG_Guid(rngGuid, Len(rngGuid), 0)
End Function

' /**
' Generate an RSA public/private key pair and save as two key files.
' @param szPubKeyFile Output filename for public key.
' @param szPriKeyFile Output filename for (encrypted) private key.
' @param szPassword Password for encrypted private key (required).
' @param nBits Required key modulus size in bits (min 96).
' @param nExpFermat Exponent [default=65537=F4]
' @param szParams Optional parameters. A set of attribute name=value pairs separated by a semicolon ";" (see remarks).
' @param  nOptions Use 0 for defaults.
' <br>
' A flag to indicate the password-based encryption scheme to be used to encrypt the private key file. Select from:
' {@code
' PKI_PBE_SHA_3DES (0) for "pbeWithSHAAnd3-KeyTripleDES-CBC" from PKCS12 (default)
' PKI_PBE_PBKDF2_DESEDE3 for PBKDF2 using des-EDE3-CBC
' PKI_PBE_PBKDF2_AES128 for PBKDF2 using aes128-CBC
' PKI_PBE_PBKDF2_AES192 for PBKDF2 using aes192-CBC
' PKI_PBE_PBKDF2_AES256 for PBKDF2 using aes256-CBC
' }
' plus optionally one of the following to output in textual PEM format [default format=DER binary]
' {@code
' PKI_KEY_FORMAT_PEM
' PKI_KEY_FORMAT_SSL
' }
' and, optionally, add `PKI_KEYGEN_INDICATE` to indicate progress in a console window.
' @return Zero if successful.
' @remark Valid name-value pair parameters for `szParams` are:<br>
' __count__=integer | To set the iteration count used in the PBKDF2 method, e.g. `"count=5000;"` [default=2048].<br>
' __prf__=hmac-name | To change the HMAC algorithm used in the PBKDF2 method, e.g. `"prf=hmacWithSHA256;"` [default=`hmacWithSHA1`].<br>
' __rngseed__=string | To add some user-supplied entropy for the key generation process, e.g. `"rngseed=pqrrr1234xyz;"`.<br>
' Valid values for hmac-name are `{hmacWithSHA1,hmacWithSHA224,hmacWithSHA256,hmacWithSHA384,hmacWithSHA512}`.
' @example
' {@code
' ' Create a 2048-bit RSA key pair using defaults
' r = rsaMakeKeys("myrsa2048.pub", "myrsa2048.p8e", "password", 2048)
' ' Same but using stronger security and in PEM format
' r = rsaMakeKeys("myrsa2048ex.pub", "myrsa2048ex.p8e", "password1", 2048,,"count=6000;prf=hmacWithSHA256", PKI_PBE_PBKDF2_AES128 Or PKI_KEY_FORMAT_PEM)
' }
'**/
Public Function rsaMakeKeys(szPubKeyFile As String, szPriKeyFile As String, szPassword As String, nBits As Long, Optional nExpFermat As Long = PKI_RSAEXP_EQ_65537, Optional szParams As String = "", Optional nOptions As Long = 0) As Long
    rsaMakeKeys = RSA_MakeKeysXtd(szPubKeyFile, szPriKeyFile, szPassword, nBits, nExpFermat, szParams, nOptions)
End Function

' /**
' Save an internal RSA key string to an encrypted key file.
' @param szOutputFile Name of output file to be created.
' @param szKeyStr The private RSA key as an internal key string.
' @param szPassword Password for encrypted private key (required).
' @param szParams Optional parameters. A set of attribute name=value pairs separated by a semicolon ";" (see remarks).
' @param  nOptions Use 0 for defaults.
' <br>
' A flag to indicate the password-based encryption scheme to be used to encrypt the private key file. Select from:
' {@code
' PKI_PBE_SHA_3DES (0) for "pbeWithSHAAnd3-KeyTripleDES-CBC" from PKCS12 (default)
' PKI_PBE_PBKDF2_DESEDE3 for PBKDF2 using des-EDE3-CBC
' PKI_PBE_PBKDF2_AES128 for PBKDF2 using aes128-CBC
' PKI_PBE_PBKDF2_AES192 for PBKDF2 using aes192-CBC
' PKI_PBE_PBKDF2_AES256 for PBKDF2 using aes256-CBC
' }
' plus optionally one of the following to output in textual PEM format [default format=DER binary]
' {@code
' PKI_KEY_FORMAT_PEM
' PKI_KEY_FORMAT_SSL
' }
' @return Zero if successful or a nonzero error code.
' @remark Valid name-value pair parameters for `szParams` are:<br>
' __count__=integer | To set the iteration count used in the PBKDF2 method, e.g. `"count=5000;"` [default=2048].<br>
' __prf__=hmac-name | To change the HMAC algorithm used in the PBKDF2 method, e.g. `"prf=hmacWithSHA256;"` [default=`hmacWithSHA1`].<br>
' Valid values for hmac-name are `{hmacWithSHA1,hmacWithSHA224,hmacWithSHA256,hmacWithSHA384,hmacWithSHA512}`.
'**/
Public Function rsaSaveEncKey(szOutputFile As String, szKeyStr As String, szPassword As String, Optional szParams As String = "", Optional nOptions As Long = 0) As Long
    rsaSaveEncKey = RSA_SaveEncKey(szOutputFile, szKeyStr, szPassword, szParams, nOptions)
End Function

' /**
' Save an internal RSA key string to a key file.
' @param szOutputFile Name of output file to be created.
' @param szKeyStr Key string (public or private) in internal format.
' @param  nOptions
' Add one of the following to output in textual PEM format [default (0) format=DER binary]
' {@code
' PKI_KEY_FORMAT_PEM
' PKI_KEY_FORMAT_SSL
' }
' @return Zero if successful or a nonzero error code.
' @remark If the key is a private key it will be saved in _unencrypted_ form.
' To save a private key in encrypted form, use {@link rsaSaveEncKey}.
'**/
Public Function rsaSaveKey(szOutputFile As String, szKeyStr As String, Optional nOptions As Long = 0) As Long
    Dim r As Long
    r = RSA_CheckKey(szKeyStr, 0)
    If r = PKI_VALID_PRIVATEKEY Then
        rsaSaveKey = RSA_SavePrivateKeyInfo(szOutputFile, szKeyStr, nOptions)
    ElseIf r = PKI_VALID_PUBLICKEY Then
        rsaSaveKey = RSA_SavePublicKey(szOutputFile, szKeyStr, nOptions)
    Else
        rsaSaveKey = r
    End If
End Function

'/**
' Decode an EME or EMSA encoded message block according to PKCS#1.
' @param  lpInput Data to be decoded.
' @param  nOptions Include one of the following:
' {@code
' PKI_EME_PKCSV1_5
' PKI_EME_OAEP
' PKI_EMSIG_PKCSV1_5
' }
' If you have selected `PKI_EMSIG_PKCSV1_5`, then you can add
' `PKI_EMSIG_DIGINFO` to decode an 'Encoded Message for Signature' block and output the whole `DigestInfo` data instead of just the message digest.
' <br>
' If you have selected PKI_EME_OAEP, then add one of these options to match the hash function used for EME-OAEP encoding:
' {@code
' PKI_HASH_SHA1
' PKI_HASH_SHA224
' PKI_HASH_SHA256
' PKI_HASH_SHA384
' PKI_HASH_SHA512
' }
' and optionally add `PKI_MGF_MGF1SHA1` to force the MGF hash function to be SHA-1 (default = same as encoding hash function set above).
' <br>
' Alternatively, ignore all the above and use the specialist option `PKI_EMSIG_ISO9796` to use the ISO9796-1 encoding for a signature.
' @return Decoded message.
' @remark EME = Encoding Method for Encryption, EMSA = Encoding Method for Signature with Appendix.
'**/
Public Function rsaDecodeMsg(lpInput() As Byte, nOptions As Long) As Byte()
    rsaDecodeMsg = vbNullString
    Dim n1 As Long
    n1 = cnvBytesLen(lpInput)
    If n1 = 0 Then Exit Function
    Dim abMyData() As Byte
    Dim nb As Long
    nb = RSA_DecodeMsg(ByVal 0&, 0, lpInput(0), n1, nOptions)
    If nb <= 0 Then Exit Function
    ReDim abMyData(nb - 1)
    nb = RSA_DecodeMsg(abMyData(0), nb, lpInput(0), n1, nOptions)
    If nb <= 0 Then Exit Function
    ReDim Preserve abMyData(nb - 1)
    rsaDecodeMsg = abMyData
End Function

'/**
' Decrypt a message encrypted using an RSA encryption scheme.
' @param  lpInput Data to be decrypted.
' @param  szPrivateKeyFile Name of the private key file, or a string containing the key in PEM format, or a valid internal private key string.
' @param  szPassword Password for encrypted private key, or `""` if password is not required.
' @param  nOptions Select one of the following:
' {@code
' PKI_EME_PKCSV1_5 (0 default)
' PKI_EME_OAEP
' }
' @param  szParameters For future use.
' @return Decrypted data or an empty array on error.
' @remark Note different order of parameters from core function.
'**/
Public Function rsaDecrypt(lpInput() As Byte, szPrivateKeyFile As String, szPassword As String, nOptions As Long, Optional szParameters As String = "") As Byte()
    ' NOTE order of parameters!
    rsaDecrypt = vbNullString
    Dim n1 As Long
    n1 = cnvBytesLen(lpInput)
    If n1 = 0 Then Exit Function
    Dim abMyData() As Byte
    Dim nb As Long
    nb = RSA_Decrypt(ByVal 0&, 0, lpInput(0), n1, szPrivateKeyFile, szPassword, szParameters, nOptions)
    If nb <= 0 Then Exit Function
    ReDim abMyData(nb - 1)
    nb = RSA_Decrypt(abMyData(0), nb, lpInput(0), n1, szPrivateKeyFile, szPassword, szParameters, nOptions)
    If nb <= 0 Then Exit Function
    ReDim Preserve abMyData(nb - 1)
    rsaDecrypt = abMyData
End Function

'/**
' Encode an EME or EMSA encoded message block according to PKCS#1.
' @param  nBlockLen Length of output block in bytes (required).
' @param  lpInput Data to be encoded.
' @param  nOptions Include one of the following:
' {@code
' PKI_EME_PKCSV1_5
' PKI_EME_OAEP
' PKI_EMSIG_PKCSV1_5
' }
' If you have selected `PKI_EMSIG_PKCSV1_5`, then add one of these options to set the hash function for the signature message digest:
' {@code
' PKI_HASH_SHA1
' PKI_HASH_SHA224
' PKI_HASH_SHA256
' PKI_HASH_SHA384
' PKI_HASH_SHA512
' PKI_HASH_MD5
' PKI_HASH_MD2
' }
' and optionally add
' `PKI_EMSIG_DIGESTONLY` as a flag to pass the message digest only as input to-be-signed (default = pass entire message).
' <br>
' If you have selected PKI_EME_OAEP, then add one of these options to set the hash function used for EME-OAEP encoding:
' {@code
' PKI_HASH_SHA1
' PKI_HASH_SHA224
' PKI_HASH_SHA256
' PKI_HASH_SHA384
' PKI_HASH_SHA512
' }
' and optionally add `PKI_MGF_MGF1SHA1` to force the MGF hash function to be SHA-1 (default = same as encoding hash function set above).
' <br>
' Alternatively, ignore all the above and use the specialist option `PKI_EMSIG_ISO9796` to use the ISO9796-1 encoding for a signature.
' @return Encoded message block.
' @remark EME = Encoding Method for Encryption, EMSA = Encoding Method for Signature with Appendix.
'**/
Public Function rsaEncodeMsg(nBlockLen As Long, lpInput() As Byte, nOptions As Long) As Byte()
    ' NB Length of output block in bytes is required
    rsaEncodeMsg = vbNullString
    Dim n1 As Long
    n1 = cnvBytesLen(lpInput)
    If n1 = 0 Then Exit Function
    Dim abMyData() As Byte
    ReDim abMyData(nBlockLen - 1)
    Dim r As Long
    r = RSA_EncodeMsg(abMyData(0), nBlockLen, lpInput(0), n1, nOptions)
    If r < 0 Then Exit Function
    rsaEncodeMsg = abMyData
End Function

'/**
' Encrypt a short message using RSA encryption.
' @param  lpInput Data to be encrypted.
' @param  szPublicKeyFile Name of the public key file or X.509 certificate,
' or a string containing the key or certificate in PEM format, or a valid internal public key string.
' @param  nOptions Select one of the following:
' {@code
' PKI_EME_PKCSV1_5 (0 default)
' PKI_EME_OAEP
' }
' If you have selected `PKI_EME_OAEP`, then add one of these options to set the hash function for EME-OAEP encoding:
' {@code
' PKI_HASH_SHA1
' PKI_HASH_SHA224
' PKI_HASH_SHA256
' PKI_HASH_SHA384
' PKI_HASH_SHA512
' }
' and, optionally, add `PKI_MGF_MGF1SHA1` to force the MGF hash function to be SHA-1 (default = same as encoding hash function set above).
' @param  szParameters For future use.
' @return Encrypted data or an empty array on error.
' @remark Note different order of parameters from core function.
'**/
Public Function rsaEncrypt(lpInput() As Byte, szPublicKeyFile As String, Optional nOptions As Long = 0, Optional szParameters As String = "") As Byte()
    ' NOTE order of parameters!
    rsaEncrypt = vbNullString
    Dim n1 As Long
    n1 = cnvBytesLen(lpInput)
    If n1 = 0 Then Exit Function
    Dim abMyData() As Byte
    Dim nb As Long
    nb = RSA_Encrypt(ByVal 0&, 0, lpInput(0), n1, szPublicKeyFile, szParameters, nOptions)
    If nb <= 0 Then Exit Function
    ReDim abMyData(nb - 1)
    nb = RSA_Encrypt(abMyData(0), nb, lpInput(0), n1, szPublicKeyFile, szParameters, nOptions)
    If nb <= 0 Then Exit Function
    ReDim Preserve abMyData(nb - 1)
    rsaEncrypt = abMyData
End Function

'/**
' Create an RSA key string in internal format from an XML string.
' @param  szXmlString The RSA public or private key in XML format.
' @param  nOptions Use default zero to include the private key, if present, or add one of:
' <br>
' `PKI_XML_EXCLPRIVATE` to exclude the private key even if present, or
' <br>
' `PKI_XML_REQPRIVATE` to require the private key to exist in the XML input or fail.
' @return Key string in internal format or empty string on error.
'**/
Public Function rsaFromXMLString(szXmlString As String, Optional nOptions As Long = 0) As String
    Dim nc As Long
    nc = RSA_FromXMLString(vbNullString, 0, szXmlString, nOptions)
    If nc <= 0 Then Exit Function
    rsaFromXMLString = String(nc, " ")
    nc = RSA_FromXMLString(rsaFromXMLString, nc, szXmlString, nOptions)
    rsaFromXMLString = Left$(rsaFromXMLString, nc)
End Function

'/**
' Get number of significant bits in RSA key modulus.
' @param  szKeyString Public or private key in internal string format.
' @return Number of significant bits in key.
'**/
Public Function rsaKeyBits(szKeyString As String) As Long
    rsaKeyBits = RSA_KeyBits(szKeyString)
End Function

'/**
' Get number of bytes (octets) in RSA key modulus.
' @param  szKeyString Public or private key in internal string format.
' @return Number of bytes in key.
'**/
Public Function rsaKeyBytes(szKeyString As String) As Long
    rsaKeyBytes = RSA_KeyBytes(szKeyString)
End Function

'/**
' Extract a base64-encoded RSA key value from internal key string.
' @param  szKeyString Public or private key in internal string format.
' @param  szFieldName Name of field to be extracted: `"Modulus"` or `"Exponent"`.
' @param  nOptions For future use.
' @return Value encoded in base64 or an empty string on error.
'**/
Public Function rsaKeyValue(szKeyString As String, szFieldName As String, Optional nOptions As Long = 0) As String
    Dim nc As Long
    nc = RSA_KeyValue(vbNullString, 0, szKeyString, szFieldName, nOptions)
    If nc <= 0 Then Exit Function
    rsaKeyValue = String(nc, " ")
    nc = RSA_KeyValue(rsaKeyValue, nc, szKeyString, szFieldName, nOptions)
    rsaKeyValue = Left$(rsaKeyValue, nc)
End Function

'/**
' Convert an internal RSA private key string into an internal public key string.
' @param  szKeyString Private key in internal string format.
' @param  nOptions For future use.
' @return String containing an internal representation of the public key, or an empty string on error.
'**/
Public Function rsaPublicKeyFromPrivate(szKeyString As String, Optional nOptions As Long = 0) As String
    Dim nc As Long
    nc = RSA_PublicKeyFromPrivate(vbNullString, 0, szKeyString, nOptions)
    If nc <= 0 Then Exit Function
    rsaPublicKeyFromPrivate = String(nc, " ")
    nc = RSA_PublicKeyFromPrivate(rsaPublicKeyFromPrivate, nc, szKeyString, nOptions)
    rsaPublicKeyFromPrivate = Left$(rsaPublicKeyFromPrivate, nc)
End Function

'/**
' Carry out RSA transformation on raw data using private key.
' @param  lpData Data to be transformed.
' @param  szPrivateKey Private key in internal string format.
' @param  nOptions For future use.
' @return Transformed data.
' @remark The data __must__ be same length as key modulus (use `RSA_KeyBytes()` to find this).
'**/
Public Function rsaRawPrivate(lpData() As Byte, szPrivateKey As String, Optional nOptions As Long = 0) As Byte()
    Dim abMyData() As Byte
    Dim nb As Long
    Dim r As Long
    rsaRawPrivate = vbNullString
    nb = cnvBytesLen(lpData)
    If nb = 0 Then Exit Function
    abMyData = lpData
    r = RSA_RawPrivate(abMyData(0), nb, szPrivateKey, nOptions)
    If r <> 0 Then Exit Function
    rsaRawPrivate = abMyData
End Function

'/**
' Carry out RSA transformation on raw data using public key.
' @param  lpData Data to be transformed.
' @param  szPublicKey Public key in internal string format.
' @param  nOptions For future use.
' @return Transformed data.
' @remark The data __must__ be same length as key modulus (use `RSA_KeyBytes()` to find this).
'**/
Public Function rsaRawPublic(lpData() As Byte, szPublicKey As String, Optional nOptions As Long = 0) As Byte()
    Dim abMyData() As Byte
    Dim nb As Long
    Dim r As Long
    rsaRawPublic = vbNullString
    nb = cnvBytesLen(lpData)
    If nb = 0 Then Exit Function
    abMyData = lpData
    r = RSA_RawPublic(abMyData(0), nb, szPublicKey, nOptions)
    If r <> 0 Then Exit Function
    rsaRawPublic = abMyData
End Function

'/**
' Read private key from a file or string containing a key into an "internal" public key string.
' @param szKeyFileOrString Name of file containing the key, or a string containing the key in PEM format or XML format.
' @param szPassword Password, if the key is encrypted, or `""` if not.
' @param  nOptions For future use.
' @return String containing an internal representation of the private key, or an empty string on error.
' @remark This function is the same as {@link rsaReadPrivateKey}.
'**/
Public Function rsaReadAnyPrivateKey(szKeyFileOrString As String, Optional szPassword As String = "", Optional nOptions As Long = 0) As String
    Dim nc As Long
    nc = RSA_ReadAnyPrivateKey(vbNullString, 0, szKeyFileOrString, szPassword, nOptions)
    If nc <= 0 Then Exit Function
    rsaReadAnyPrivateKey = String(nc, " ")
    nc = RSA_ReadAnyPrivateKey(rsaReadAnyPrivateKey, nc, szKeyFileOrString, szPassword, nOptions)
    rsaReadAnyPrivateKey = Left$(rsaReadAnyPrivateKey, nc)
End Function

'/**
' Read public key from a file or string containing a key into an "internal" public key string.
' @param szKeyFileOrString Name of file containing the key, or a string containing the key in PEM format or XML format.
' @param  nOptions For future use.
' @return String containing an internal representation of the public key, or an empty string on error.
' @remark This function is the same as {@link rsaReadPublicKey}.
'**/
Public Function rsaReadAnyPublicKey(szKeyFileOrString As String, Optional nOptions As Long = 0) As String
    Dim nc As Long
    nc = RSA_ReadAnyPublicKey(vbNullString, 0, szKeyFileOrString, nOptions)
    If nc <= 0 Then Exit Function
    rsaReadAnyPublicKey = String(nc, " ")
    nc = RSA_ReadAnyPublicKey(rsaReadAnyPublicKey, nc, szKeyFileOrString, nOptions)
    rsaReadAnyPublicKey = Left$(rsaReadAnyPublicKey, nc)
End Function

'/**
' Create an XML string representation of an RSA internal key string.
' @param  szKeyString The RSA public or private key in internal format.
' @param  nOptions Default (0) to output in appropriate W3C standard format
' (`RSAKeyValue` for public key and `RSAKeyPair` for private key), or select and combine:
' <br>
' `PKI_XML_RSAKEYVALUE` to force private key output as .NET-compatible `RSAKeyValue` format (instead of W3C `RSAKeyPair`)
' <br>
' `PKI_XML_EXCLPRIVATE` to exclude the private key (use to get a public key `RSAKeyValue` from a private key)
' <br>
' `PKI_XML_HEXBINARY` to output with data in non-conforming (but convenient) `hexBinary` format.
' @return XML string or empty string on error.
'**/
Public Function rsaToXMLString(szKeyString As String, Optional nOptions As Long = 0) As String
    Dim nc As Long
    nc = RSA_ToXMLString(vbNullString, 0, szKeyString, nOptions)
    If nc <= 0 Then Exit Function
    rsaToXMLString = String(nc, " ")
    nc = RSA_ToXMLString(rsaToXMLString, nc, szKeyString, nOptions)
    rsaToXMLString = Left$(rsaToXMLString, nc)
End Function

'/**
' Create an XML string representation of an RSA internal key string with option to add a namespace prefix.
' @param  szKeyString The RSA public or private key in internal format.
' @param  szPrefix Namespace prefix to be added to all elements, e.g. `"ds"`.
' @param  nOptions Default (0) to output in appropriate W3C standard format
' (`RSAKeyValue` for public key and `RSAKeyPair` for private key), or select and combine:
' <br>
' `PKI_XML_RSAKEYVALUE` to force private key output as .NET-compatible `RSAKeyValue` format (instead of W3C `RSAKeyPair`)
' <br>
' `PKI_XML_EXCLPRIVATE` to exclude the private key (use to get a public key `RSAKeyValue` from a private key)
' <br>
' `PKI_XML_HEXBINARY` to output with data in non-conforming (but convenient) `hexBinary` format.
' @return XML string or empty string on error.
' @remark Use this extended function to add a namespace prefix to all elements in the XML output; for example, `&lt;ds:RSAKeyValue&gt;`.
'**/
Public Function rsaToXMLStringEx(szKeyString As String, szPrefix As String, Optional nOptions As Long = 0) As String
    Dim nc As Long
    nc = RSA_ToXMLStringEx(vbNullString, 0, szKeyString, szPrefix, nOptions)
    If nc <= 0 Then Exit Function
    rsaToXMLStringEx = String(nc, " ")
    nc = RSA_ToXMLStringEx(rsaToXMLStringEx, nc, szKeyString, szPrefix, nOptions)
    rsaToXMLStringEx = Left$(rsaToXMLStringEx, nc)
End Function

'/**
' Compute a signature value over data in a byte array.
' @param  lpData Data to be signed.
' @param  szKeyFile name of the private key file or a string containing the key in PEM format, or a valid internal private key string.
' @param  szPassword Password for the private key, or `""` if not required.
' @param  szAlgName Signature algorithm to be used:
' {@code
' "sha1WithRSAEncryption"
' "sha224WithRSAEncryption"
' "sha256WithRSAEncryption"
' "sha384WithRSAEncryption"
' "sha512WithRSAEncryption"
' "md5WithRSAEncryption"
' "ecdsaWithSHA1"
' "ecdsaWithSHA224"
' "ecdsaWithSHA256"
' "ecdsaWithSHA384"
' "ecdsaWithSHA512"
' "RSA-PSS-SHA1"
' "RSA-PSS-SHA224"
' "RSA-PSS-SHA256"
' "RSA-PSS-SHA384"
' "RSA-PSS-SHA512"
' "Ed25519"
' }
' @param  nOptions Use 0 for defaults.
' <br>
' Add the bitflag `PKI_SIG_USEDIGEST` to pass the digest value of the data-to-be-signed as the `lpData` argument.
' <br>
' To change the format of the output (default base64 encoded), add one of:
' {@code
' PKI_ENCODE_BASE64URL
' PKI_ENCODE_HEX
' }
' Options for ECDSA signatures only:
' {@code
' PKI_SIG_DETERMINISTIC
' PKI_SIG_ASN1DER
' }
' Options for RSA-PSS signatures only to set the salt length (default = `hLen`):
' {@code
' PKI_PSS_SALTLEN_HLEN
' PKI_PSS_SALTLEN_MAX
' PKI_PSS_SALTLEN_20
' PKI_PSS_SALTLEN_ZERO
' }
' and, optionally, add `PKI_MGF_MGF1SHA1` to force the MGF hash function to be SHA-1 (default = same as signature hash algorithm).
' @return The signature encoded in base64, or an empty string on error.
'**/
Public Function sigSignData(lpData() As Byte, szKeyFile As String, szPassword As String, szAlgName As String, Optional nOptions As Long = 0) As String
    Dim n1 As Long
    n1 = cnvBytesLen(lpData)
    If n1 = 0 Then Exit Function
    Dim nc As Long
    nc = SIG_SignData(vbNullString, 0, lpData(0), n1, szKeyFile, szPassword, szAlgName, nOptions)
    If nc <= 0 Then Exit Function
    sigSignData = String(nc, " ")
    nc = SIG_SignData(sigSignData, nc, lpData(0), n1, szKeyFile, szPassword, szAlgName, nOptions)
    sigSignData = Left$(sigSignData, nc)
End Function

'/**
' Compute a signature value over data in a file.
' @param  szDataFile Name of file to be signed.
' @param  szKeyFile name of the private key file or a string containing the key in PEM format, or a valid internal private key string.
' @param  szPassword Password for the private key, or `""` if not required.
' @param  szAlgName Signature algorithm to be used:
' {@code
' "sha1WithRSAEncryption"
' "sha224WithRSAEncryption"
' "sha256WithRSAEncryption"
' "sha384WithRSAEncryption"
' "sha512WithRSAEncryption"
' "md5WithRSAEncryption"
' "ecdsaWithSHA1"
' "ecdsaWithSHA224"
' "ecdsaWithSHA256"
' "ecdsaWithSHA384"
' "ecdsaWithSHA512"
' "RSA-PSS-SHA1"
' "RSA-PSS-SHA224"
' "RSA-PSS-SHA256"
' "RSA-PSS-SHA384"
' "RSA-PSS-SHA512"
' }
' @param  nOptions Use 0 for defaults.
' <br>
' To change the format of the output (default base64 encoded), add one of:
' {@code
' PKI_ENCODE_BASE64URL
' PKI_ENCODE_HEX
' }
' Options for ECDSA signatures only:
' {@code
' PKI_SIG_DETERMINISTIC
' PKI_SIG_ASN1DER
' }
' Options for RSA-PSS signatures only to set the salt length (default = `hLen`):
' {@code
' PKI_PSS_SALTLEN_HLEN
' PKI_PSS_SALTLEN_MAX
' PKI_PSS_SALTLEN_20
' PKI_PSS_SALTLEN_ZERO
' }
' and, optionally, add `PKI_MGF_MGF1SHA1` to force the MGF hash function to be SHA-1 (default = same as signature hash algorithm).
' @return The signature encoded in base64, or an empty string on error.
' @remark Ed25519 is not available with this function. To sign using Ed25519, read in the file to a byte array and use `sigSignData()`.
'**/
Public Function sigSignFile(szDataFile As String, szKeyFile As String, szPassword As String, szAlgName As String, Optional nOptions As Long = 0) As String
    Dim nc As Long
    nc = SIG_SignFile(vbNullString, 0, szDataFile, szKeyFile, szPassword, szAlgName, nOptions)
    If nc <= 0 Then Exit Function
    sigSignFile = String(nc, " ")
    nc = SIG_SignFile(sigSignFile, nc, szDataFile, szKeyFile, szPassword, szAlgName, nOptions)
    sigSignFile = Left$(sigSignFile, nc)
End Function

'/**
' Query an S/MIME entity for selected information.
' @param  szFileIn Name of input file.
' @param  szQuery Query string (case insensitive). Valid queries are:
' {@code
' "content-type"
' "smime-type"
' "encoding"
' "name"
' "filename"
' }
' @param  nOptions For future use.
' @return String containing the result or an empty string if not found or error.
' @example
' {@code
' Debug.Print smimeQuery("cmsalice2bob-smime-env.txt", "smime-type")
' enveloped-data
' }
'**/
Public Function smimeQuery(szFileIn As String, szQuery As String, Optional nOptions As Long = 0) As String
    Dim nc As Long
    nc = SMIME_Query(vbNullString, 0, szFileIn, szQuery, nOptions)
    If nc <= 0 Then Exit Function
    smimeQuery = String(nc, " ")
    nc = SMIME_Query(smimeQuery, nc, szFileIn, szQuery, nOptions)
    smimeQuery = Left$(smimeQuery, nc)
End Function

'/**
' Calculate the thumbprint (message digest value) of an X.509 certificate.
' @param  szCertFile Name of input file.
' @param  nOptions Algorithm to be used. Select one from:
' {@code
' PKI_HASH_SHA1 (0 = default)
' PKI_HASH_SHA224
' PKI_HASH_SHA256
' PKI_HASH_SHA384
' PKI_HASH_SHA512
' PKI_HASH_MD5
' }
' @return Message digest in hex format or empty string on error.
'**/
Public Function x509CertThumb(szCertFile As String, Optional nOptions As Long = 0) As String
    Dim nc As Long
    x509CertThumb = String(PKI_MAX_HASH_CHARS, " ")
    nc = X509_CertThumb(szCertFile, x509CertThumb, Len(x509CertThumb), nOptions)
    If nc <= 0 Then Exit Function
    x509CertThumb = Left$(x509CertThumb, nc)
End Function

'/**
' Calculate the message digest hash of the PKCS #7 issuerAndSerialNumber value of an X.509 certificate.
' @param  szCertFile Name of input file.
' @param  nOptions Algorithm to be used. Select one from:
' {@code
' PKI_HASH_SHA1 (0 = default)
' PKI_HASH_SHA224
' PKI_HASH_SHA256
' PKI_HASH_SHA384
' PKI_HASH_SHA512
' PKI_HASH_MD5
' }
' @return Message digest in hex format or empty string on error.
'**/
Public Function x509HashIssuerAndSN(szCertFile As String, Optional nOptions As Long = 0) As String
    Dim nc As Long
    x509HashIssuerAndSN = String(PKI_MAX_HASH_CHARS, " ")
    nc = X509_HashIssuerAndSN(szCertFile, x509HashIssuerAndSN, Len(x509HashIssuerAndSN), nOptions)
    If nc <= 0 Then Exit Function
    x509HashIssuerAndSN = Left$(x509HashIssuerAndSN, nc)
End Function

'/**
' Query an X.509 certificate file for selected information.
' @param  szCertFile Name of X.509 certificate file (or base64 representation).
' @param  szQuery Query string (case insensitive). Valid queries are:
' {@code
' "version"
' "serialNumber"
' "signatureAlgorithm"
' "sigAlgId"
' "signatureValue"
' "notBefore"
' "notAfter"
' "issuerName"
' "subjectName"
' "subjectPublicKeyAlgorithm"
' "subjectKeyIdentifier"
' "authorityKeyIdentifier"
' "rfc822Name"
' "isCA"
' "keyUsageString"
' "extKeyUsageString"
' "cRLDistributionPointsURI"
' "authorityInfoAccessURI"
' "subjectAltName"
' "hashAlgorithm"
' "pssParams"
' }
' @param  nOptions Use 0 for default or add any of:
' {@code
' PKI_X509_LATIN1 or PKI_X509_UTF8
' PKI_X509_LDAP
' PKI_X509_DECIMAL
' }
' @return String containing the result or an empty string if not found or error.
' @remark `PKI_X509_UTF8` will output attribute string encoded in UTF-8.
' `PKI_X509_LATIN1` will _attempt_ to convert output to Latin-1 encoding.
' @example
' {@code
' Debug.Print x509QueryCert("AliceRSASignByCarl.cer", "subjectName")
' CN=AliceRSA
' }
'**/
Public Function x509QueryCert(szCertFile As String, szQuery As String, Optional nOptions As Long = 0) As String
    Dim n As Long
    n = X509_QueryCert("", 0, "", szQuery, PKI_QUERY_GETTYPE)
    If PKI_QUERY_NUMBER = n Then
        ' Output is a number, but here we return it as a string, e.g. "256"
        n = X509_QueryCert("", 0, szCertFile, szQuery, nOptions)
        If n <= 0 Then Exit Function
        x509QueryCert = CStr(n)
    ElseIf PKI_QUERY_STRING = n Then
        ' Output is a string
        Dim nc As Long
        nc = X509_QueryCert(vbNullString, 0, szCertFile, szQuery, nOptions)
        If nc <= 0 Then Exit Function
        x509QueryCert = String(nc, " ")
        nc = X509_QueryCert(x509QueryCert, nc, szCertFile, szQuery, nOptions)
        x509QueryCert = Left$(x509QueryCert, nc)
    End If
End Function

'/**
' Read an X.509 certificate into a base64-encoded string from PKCS-7 "certs-only" data.
' @param  szP7cFile Filename of a PKCS-7 "certs-only" file, or a string containing its PEM textual representation.
' @param  nIndex Index of certificate (1,2,...) in the chain to extract.
' @param  nOptions For future use.
' @return String in continuous base64 format, or an empty string on error or if not found.
' @remark Use `X509_GetCertCountInP7Chain()` to find number of certificates in the chain.
'**/
Public Function x509ReadCertStringFromP7Chain(szP7cFile As String, nIndex As Long, Optional nOptions As Long = 0) As String
    Dim nc As Long
    ' Require index > 0
    If nIndex <= 0 Then Exit Function
    nc = X509_ReadCertStringFromP7Chain(vbNullString, 0, szP7cFile, nIndex, nOptions)
    If nc <= 0 Then Exit Function
    x509ReadCertStringFromP7Chain = String(nc, " ")
    nc = X509_ReadCertStringFromP7Chain(x509ReadCertStringFromP7Chain, nc, szP7cFile, nIndex, nOptions)
    x509ReadCertStringFromP7Chain = Left$(x509ReadCertStringFromP7Chain, nc)
End Function

'/**
' Read an X.509 certificate into a base64-encoded string from PKCS-12 PFX/.p12 data.
' @param  szPfxFile Filename of a PFX file, or a string containing its PEM textual representation.
' @param  szPassword Password or `""` if certificate is not encrypted.
' @param  nOptions For future use.
' @return String in continuous base64 format, or an empty string on error.
'**/
Public Function x509ReadCertStringFromPFX(szPfxFile As String, szPassword As String, Optional nOptions As Long = 0) As String
    Dim nc As Long
    nc = X509_ReadCertStringFromPFX(vbNullString, 0, szPfxFile, szPassword, nOptions)
    If nc <= 0 Then Exit Function
    x509ReadCertStringFromPFX = String(nc, " ")
    nc = X509_ReadCertStringFromPFX(x509ReadCertStringFromPFX, nc, szPfxFile, szPassword, nOptions)
    x509ReadCertStringFromPFX = Left$(x509ReadCertStringFromPFX, nc)
End Function

'/**
' Read an X.509 certificate into a base64-encoded string.
' @param  szCertFile Name of X.509 certificate file.
' @param  nOptions For future use.
' @return String in continuous base64 format, or an empty string on error.
'**/
Public Function x509ReadStringFromFile(szCertFile As String, Optional nOptions As Long = 0) As String
    Dim nc As Long
    nc = X509_ReadStringFromFile(vbNullString, 0, szCertFile, nOptions)
    If nc <= 0 Then Exit Function
    x509ReadStringFromFile = String(nc, " ")
    nc = X509_ReadStringFromFile(x509ReadStringFromFile, nc, szCertFile, nOptions)
    x509ReadStringFromFile = Left$(x509ReadStringFromFile, nc)
End Function

'/**
' Dump details of an X.509 certificate or a X.509 certificate revocation list (CRL) or a PKCS-10 certificate signing request (CSR) to a string.
' @param  szCertFile Name of input file (or its base64 or PEM string representation).
' @param  nOptions Use 0 for default or add any of:
' {@code
' PKI_X509_LATIN1
' PKI_X509_LDAP
' PKI_X509_DECIMAL
' }
' @return String containing the result, or an empty string on error.
'**/
Public Function x509TextDumpToString(szCertFile As String, Optional nOptions As Long = 0) As String
    Dim nc As Long
    nc = X509_TextDumpToString(vbNullString, 0, szCertFile, nOptions)
    If nc <= 0 Then Exit Function
    x509TextDumpToString = String(nc, " ")
    nc = X509_TextDumpToString(x509TextDumpToString, nc, szCertFile, nOptions)
    x509TextDumpToString = Left$(x509TextDumpToString, nc)
End Function

' New in [v6.20] more convenient synonyms

'/**
' Encodes an array of bytes as a hexadecimal-encoded string.
' @param lpData Input byte array
' @return Hexadecimal-encoded string
' @remark A shorter synonym for {@link cnvHexStrFromBytes}
'**/
Public Function cnvToHex(lpData() As Byte) As String
    cnvToHex = cnvHexStrFromBytes(lpData)
End Function

'/**
' Decodes a hexadecimal-encoded string as an array of bytes.
' @param strHex Hexadecimal-encoded data to be decoded.
' @return Array of bytes.
' @remark A shorter synonym for {@link cnvBytesFromHexStr}
'**/
Public Function cnvFromHex(strHex As String) As Byte()
    cnvFromHex = cnvBytesFromHexStr(strHex)
End Function

'/**
' Encodes an array of bytes as a base64-encoded string.
' @param lpData Input byte array
' @return Base64-encoded string
' @remark A shorter synonym for {@link cnvB64StrFromBytes}
'**/
Public Function cnvToBase64(lpData() As Byte) As String
    cnvToBase64 = cnvB64StrFromBytes(lpData)
End Function

'/**
' Decodes a base64-encoded string as an array of bytes.
' @param strBase64 Base64 data to be decoded.
' @return Array of bytes.
' @remark A shorter synonym for {@link cnvBytesFromB64Str}
'**/
Public Function cnvFromBase64(strBase64 As String) As Byte()
    cnvFromBase64 = cnvBytesFromB64Str(strBase64)
End Function

'/**
' Return a substring of bytes of specified length from within a given byte array
' @param Bytes Byte array from which to return a substring (of bytes)
' @param nOffset Offset at which substring begins. First byte is at offset zero.
' @param nBytes Number of bytes in substring (optional). If negative, copy to end of input.
' @return A byte array containing a specified number of bytes from a byte array.
'**/
Public Function cnvBytesMid(Bytes() As Byte, nOffset As Long, Optional nBytes As Long = -1) As Byte()
    cnvBytesMid = vbNullString
    Dim MyBytes() As Byte
    Dim nLen As Long
    Dim i As Long
    Dim nRest As Long
    Dim nToCopy As Long
    nLen = cnvBytesLen(Bytes)
    ' Cases with empty string output
    If nLen = 0 Then Exit Function
    If nBytes = 0 Then Exit Function
    If nOffset >= nLen Then Exit Function
    ' Max bytes to copy to end of string
    nRest = nLen - nOffset
    If nBytes < 0 Then
        nToCopy = nRest
    Else
        nToCopy = nBytes
    End If
    If nToCopy > nRest Then nToCopy = nRest
    ReDim MyBytes(nToCopy - 1)
    For i = 0 To nToCopy - 1
        MyBytes(i) = Bytes(i + nOffset)
    Next
    cnvBytesMid = MyBytes
End Function

'/**
' Return an error message string for the last error.
' @param nErrCode Error code returned by last call (or zero if no code available).
' @param szMsg Optional message to add.
' @return Error message as a string including previous ErrorCode, if available.
' @example
' {@code
' Error (11): Parameter out of range (RANGE_ERROR)
' }
'**/
Public Function errFormatErrorMessage(Optional nErrCode As Long = 0, Optional szMsg As String = "") As String
    Dim nLastCode As Long
    Dim lasterror As String
    errFormatErrorMessage = vbNullString
    If nErrCode < 0 Then nErrCode = -nErrCode
    ' Get previous errors, if available
    lasterror = pkiLastError()
    nLastCode = pkiErrorCode()
    If nErrCode = 0 And nLastCode = 0 And Len(lasterror) = 0 Then
        Exit Function
    End If
    ' Compose error message
    If Len(szMsg) > 0 Then
        errFormatErrorMessage = errFormatErrorMessage & szMsg & ": "
    End If
    errFormatErrorMessage = errFormatErrorMessage & "Error"
    If nErrCode <> 0 Then
        errFormatErrorMessage = errFormatErrorMessage & "(" & nErrCode & ")"
    End If
    ' Get error message for code errCode
    If (nErrCode <> 0) Then
        errFormatErrorMessage = errFormatErrorMessage & ": " & pkiErrorLookup(nErrCode)
    End If
    If nLastCode <> 0 And nErrCode <> nLastCode Then
        errFormatErrorMessage = errFormatErrorMessage & ": " & pkiErrorLookup(nLastCode)
    End If
    If Len(lasterror) > 0 Then
        errFormatErrorMessage = errFormatErrorMessage & ": " & lasterror
    End If

End Function


' ... END OF MODULE
' *******************************************************************

'''''''''''''''''''''''''''''''Bonus
Public Function WriteFileFromString(sFilePath As String, strIn As String) As Boolean
' Creates a file from a string. Clobbers any existing file.
On Error GoTo OnError
    Dim hFile As Integer
    
    If Len(Dir(sFilePath)) > 0 Then
        Kill sFilePath
    End If
    hFile = FreeFile
    Open sFilePath For Binary Access Write As #hFile
    Put #hFile, , strIn
    Close #hFile
    WriteFileFromString = True
Done:
    Exit Function
OnError:
    Resume Done
    
End Function